var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>The <code>quansino</code> code aims to provide a simple-to-use platform for quickly creating customized Monte Carlo simulations. The code is based on the Atomic Simulation Environment (ASE) and aim to be modular and flexible.</p> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":""},{"location":"about/changelog.html#003","title":"[0.0.3]","text":"<ul> <li>Bumped NumPy version to 2.1.3 in tests</li> <li>Fixed issue with .codecov.yml for <code>quansino.type_hints</code> module</li> <li>Releasing for Zenodo DOI</li> </ul>"},{"location":"about/changelog.html#002","title":"[0.0.2]","text":""},{"location":"about/changelog.html#added","title":"Added","text":""},{"location":"about/changelog.html#grand-canonical-monte-carlo","title":"Grand Canonical Monte Carlo","text":"<ul> <li>Added implementation of Grand Canonical (\u03bcVT) Monte Carlo ensemble</li> <li>Introduced <code>GrandCanonical</code> class with support for chemical potential calculations</li> <li>Added <code>GrandCanonicalCriteria</code> for move acceptance in Grand Canonical ensemble</li> <li>Implemented particle insertion and deletion moves with volume consideration</li> </ul>"},{"location":"about/changelog.html#monte-carlo-core-improvements","title":"Monte Carlo Core Improvements","text":"<ul> <li>Introduced generics for improved type safety across Monte Carlo implementations</li> <li>Added generic <code>Context</code> system for managing simulation state</li> <li>Implemented <code>MoveStorage</code> for better organization of moves and their parameters</li> <li>Added comprehensive acceptance criteria framework</li> <li>Improved move selection and probability handling</li> </ul>"},{"location":"about/changelog.html#moves-and-operations","title":"Moves and Operations","text":"<ul> <li>Added composite displacement moves through <code>CompositeDisplacementMove</code></li> <li>Improved exchange moves with better particle tracking</li> <li>Enhanced move operations with clearer separation of concerns</li> <li>Added support for molecular insertions and deletions</li> <li>Improved handling of move constraints and boundaries</li> </ul>"},{"location":"about/changelog.html#python-support","title":"Python Support","text":"<ul> <li>Updated Python version requirements to 3.12+</li> <li>Added support for Python 3.13</li> <li>Removed support for Python 3.10 and 3.11</li> </ul>"},{"location":"about/changelog.html#code-quality","title":"Code Quality","text":"<ul> <li>Added improved type hints throughout the codebase</li> <li>Enhanced error handling and validation</li> <li>Improved code organization and modularity</li> <li>Added more comprehensive unit tests</li> <li>Implemented better class inheritance structures</li> </ul>"},{"location":"about/changelog.html#logging-and-io","title":"Logging and I/O","text":"<ul> <li>Enhanced logging system with better formatting</li> <li>Improved header handling in log files</li> <li>Added more flexible field formatting options</li> <li>Better handling of logging contexts</li> <li>Added support for stress tensor logging</li> </ul>"},{"location":"about/changelog.html#internal-changes","title":"Internal Changes","text":"<ul> <li>Reorganized package structure</li> <li>Improved test coverage</li> <li>Enhanced type safety with generics</li> <li>Better separation of concerns in move implementations</li> <li>Improved code reusability and maintainability</li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>README.md, setting up the template and cleaning up the documentation.</li> <li>Base class for <code>BaseMove</code> and <code>MonteCarlo</code>.</li> <li><code>DisplacementMove</code>, <code>ExchangeMove</code> for displacement and exchange moves.</li> <li><code>DisplacementContext</code>, <code>ExchangeContext</code> for context management between moves and simulation objects.</li> <li><code>Canonical</code> class for canonical ensemble NVT simulations.</li> <li>Various operations for <code>DisplacementMove</code> and <code>ExchangeMove</code>, such as <code>Ball</code>, <code>Sphere</code> and <code>Box</code> operations.</li> <li><code>ForceBias</code> class based on the work of K. M Bal and E. C. Neyts, J. Chem. Phys. 141, 204104 (2014).</li> <li>Added the logo for the project.</li> <li>Set up the CI/CD pipeline with GitHub Actions.</li> <li>Various utils for supporting the project such as <code>search_molecules</code> and <code>reinsert_atoms</code>.</li> </ul>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2025, Tom Demeyere. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"documentation/examples.html","title":"Examples","text":"<p>This page contains examples of how to use <code>quansino</code> to run various Monte Carlo simulations.</p>"},{"location":"documentation/examples.html#orb-v3-examples","title":"orb-v3 examples","text":""},{"location":"documentation/examples.html#cu-bulk-fcc-canonical-ensemble","title":"Cu-bulk (fcc) canonical ensemble","text":"<p>Below is an example of how to run a canonical ensemble simulation for a bulk copper (Cu) system using the <code>orb-v3</code> MLIP with the <code>quansino</code> package. The simulation is carried out at 500 K, performing displacement moves on all the atoms in the system. The trajectory is saved to an XYZ file, logging is directly sent to standard output, and the simulation is seeded for reproducibility.</p> <pre><code>from __future__ import annotations\n\nfrom sys import stdout\n\nimport numpy as np\nfrom ase.build import bulk\nfrom orb_models.forcefield import pretrained\nfrom orb_models.forcefield.calculator import ORBCalculator\n\nfrom quansino.mc.canonical import Canonical\nfrom quansino.moves.displacement import DisplacementMove\n\ndevice = \"cpu\"\norbff = pretrained.orb_v3_conservative_inf_omat(device=device, precision=\"float32-high\")\ncalc = ORBCalculator(orbff, device=device)\n\natoms = bulk(\"Cu\", \"fcc\", cubic=True)\natoms.calc = calc\n\nmc = Canonical(\n    atoms,\n    temperature=500,\n    max_cycles=len(atoms),\n    default_displacement_move=DisplacementMove(labels=np.arange(len(atoms))),\n    seed=42,\n    logging_interval=1,\n    logfile=stdout,\n    trajectory=\"orb-v3_canonical_bulk_cu.xyz\",\n    logging_mode=\"w\",\n)\n\nmc.run(1000)\n</code></pre>"},{"location":"documentation/examples.html#cu-bulk-fcc-npt-ensemble","title":"Cu-bulk (fcc) NPT ensemble","text":"<p>Below is an example of how to run an NPT ensemble simulation for a bulk copper (Cu) system using the <code>orb-v3</code> MLIP with the <code>quansino</code> package. The simulation is performed at 500 K and 0 atm, with various moves applied to the system.</p> <pre><code>from __future__ import annotations\n\nfrom sys import stdout\n\nimport numpy as np\nfrom ase.build import bulk\nfrom orb_models.forcefield import pretrained\nfrom orb_models.forcefield.calculator import ORBCalculator\n\nfrom quansino.mc.criteria import IsobaricCriteria\nfrom quansino.mc.isobaric import Isobaric\nfrom quansino.moves.cell import CellMove\nfrom quansino.moves.displacement import DisplacementMove\nfrom quansino.protocols import Criteria, Move\n\ndevice = \"cpu\"\norbff = pretrained.orb_v3_conservative_inf_omat(device=device, precision=\"float32-high\")\ncalc = ORBCalculator(orbff, device=device)\natoms = bulk(\"Cu\", \"fcc\", cubic=True)\n\natoms.calc = calc\n\nmc = Isobaric[Move, Criteria](\n    atoms,\n    temperature=500,\n    max_cycles=len(atoms),\n    default_displacement_move=DisplacementMove(labels=np.arange(len(atoms))),\n    default_cell_move=CellMove(),\n    seed=42,\n    logging_interval=1,\n    logfile=stdout,\n    trajectory=\"orb-v3_isobaric_bulk_cu.xyz\",\n    logging_mode=\"w\",\n)\n\nfor steps in mc.irun(100):\n    for _ in steps:\n        pass\n\n\ndel mc.moves[\"default_displacement_move\"]\ndel mc.moves[\"default_cell_move\"]\n\n\nhybrid_move = DisplacementMove(labels=np.arange(len(atoms))) * len(atoms) + CellMove()\nmc.max_cycles = 1\n\nmc.add_move(hybrid_move, name=\"hybrid_move\", criteria=IsobaricCriteria())\n\nfor _ in mc.srun(100):\n    pass\n</code></pre>"},{"location":"documentation/examples.html#pt-nanocluster-fcc-gcmc-ensemble-oxygen-adsorption","title":"Pt nanocluster (fcc) GCMC ensemble, oxygen adsorption","text":"<p>Below is an example of how to run a Grand Canonical Monte Carlo (GCMC) simulation for a platinum (Pt) nanocluster system using the <code>orb-v3</code> MLIP with the <code>quansino</code> package. The simulation is performed at 298.15 K, with oxygen exchange moves applied to the system.</p> <pre><code>from __future__ import annotations\n\nfrom sys import stdout\n\nimport numpy as np\nfrom ase.atoms import Atoms\nfrom ase.build import molecule\nfrom ase.cluster import Octahedron\nfrom ase.optimize import BFGSLineSearch\nfrom orb_models.forcefield import pretrained\nfrom orb_models.forcefield.calculator import ORBCalculator\n\nfrom quansino.mc.gcmc import GrandCanonical\nfrom quansino.moves.displacement import DisplacementMove\nfrom quansino.moves.exchange import ExchangeMove\n\natoms = Octahedron(\"Pt\", 4)\natoms.center(10)\n\ncom = atoms.get_center_of_mass()\n\no2_molecule = molecule(\"O2\", vacuum=10.0)\n\ndevice = \"cpu\"\norbff = pretrained.orb_v3_conservative_inf_omat(device=device, precision=\"float32-high\")\ncalc = ORBCalculator(orbff, device=device)\natoms.calc = calc\no2_molecule.calc = calc\n\no2_molecule_bfgs = BFGSLineSearch(o2_molecule)\no2_molecule_bfgs.run(fmax=0.01, steps=100)\n\nenergy = o2_molecule.get_potential_energy()\n\nchemical_potential = 0.5 * (0.633926342106 + energy - 0.1)  # From NIST, ZPE adjusted\n\ngas = Atoms(\"O\")\n\nmc = GrandCanonical(\n    atoms,\n    exchange_atoms=gas,\n    chemical_potential=chemical_potential,\n    temperature=298.15,\n    number_of_exchange_particles=0,\n    max_cycles=len(atoms),\n    default_displacement_move=DisplacementMove(labels=np.arange(len(atoms))),\n    default_exchange_move=ExchangeMove(labels=np.full(len(atoms), -1)),\n    seed=42,\n    logging_interval=1,\n    logfile=stdout,\n    trajectory=\"orb-v3_grand_canonical_pt_np.xyz\",\n    logging_mode=\"w\",\n)\n\nmc.moves[\"default_exchange_move\"].probability = 0.1\nmc.moves[\"default_displacement_move\"].probability = 0.9\n\nmc.run(100)\n</code></pre> <p>Running the simulation will result in the following logger output:</p> <pre><code>Step Epot[eV] AcptRate Natoms\n0 -218.0509 0.000 44\n1 -218.1546 0.614 44\n2 -218.5050 0.636 44\n3 -218.5735 0.614 44\n4 -218.3855 0.659 44\n5 -218.5388 0.636 44\n6 -218.5623 0.636 44\n7 -218.7438 0.795 44\n8 -218.7147 0.500 44\n9 -218.7750 0.614 44\n10 -218.9371 0.568 44\n11 -218.9552 0.591 44\n12 -219.1030 0.614 44\n13 -219.1480 0.614 44\n14 -219.3729 0.614 44\n15 -219.2637 0.500 44\n16 -219.3318 0.545 44\n</code></pre> <p>The logger shows that the acceptance rate is around 0.6, which is reasonable, but the number of atoms remains constant. This means that most accepted moves are displacement moves, and the exchange move is not being accepted. This is because we attempt to place oxygen atoms everywhere in the unit cell, which is not desirable.</p> <p>Instead, we want to attempt moves only close to the nanoparticle where the atoms can bind and have enough excess chemical potential to be accepted. To do this, we can customize the <code>check_move</code> attribute of the <code>ExchangeMove</code> to only accept moves that are close to the nanoparticle. Below is an example of how to do this:</p> <pre><code>...\n\n\ndef check_move(context: ExchangeContext) -&gt; bool:\n    \"\"\"\n    Check if the move can be performed based on the center of mass distance.\n\n    Returns\n    -------\n    bool\n        True if the move can be performed, False otherwise.\n    \"\"\"\n    atoms_about_to_be_placed = atoms[mc.context._moving_indices]\n    com_distance = (\n        atoms_about_to_be_placed.positions  # type: ignore[shape]\n        - atoms[atoms.symbols == \"Pt\"].get_center_of_mass()  # type: ignore[shape]\n    )\n\n    return not bool(np.any(np.linalg.norm(com_distance, axis=1) &gt; 8.0))\n\n\nmc.moves[\"default_exchange_move\"].move.check_move = check_move\n</code></pre> <p>In this way, the exchange move will attempt to place oxygen atoms only within a certain distance. If the distance is too large, it will retry a placement. This is done <code>move.max_attempts</code> times, which is set to 10,000 by default. If the move can't find a suitable position after all attempts, it will be rejected.</p> <p>We also change the <code>accessible_volume</code> attribute of the <code>GrandCanonical</code> class to reflect the volume where the oxygen atoms can be placed. This is important for the acceptance rate calculation.</p> <pre><code>mc.accessible_volume = np.pi * 3 / 4 * (8.0**3)\n</code></pre> <p>After these changes, we can run the simulation again and get the following output:</p> <pre><code>Step Epot[eV] AcptRate Natoms\n0 -218.0509 0.000 44\n1 -218.0484 0.636 44\n2 -218.1835 0.636 44\n3 -218.3500 0.636 44\n4 -218.3445 0.545 44\n5 -218.3713 0.636 44\n6 -218.5544 0.432 44\n7 -223.5220 0.636 45\n8 -223.6393 0.545 45\n9 -223.6890 0.591 45\n10 -223.7481 0.545 45\n11 -224.1059 0.614 45\n12 -224.1784 0.636 45\n13 -224.2668 0.614 45\n14 -224.2314 0.545 45\n15 -224.3243 0.568 45\n16 -228.7678 0.568 46\n</code></pre> <p>We can see the number of atoms is increasing, indicating that the exchange move is being accepted and oxygen atoms are being placed in the system. Still, we might want to increase the acceptance rate further by using <code>quansino</code>'s flexibility and creating a custom criteria for the exchange move that optimizes the system before running the criteria:</p> <pre><code>from quansino.mc.criteria import GrandCanonicalCriteria\n\n\nclass GrandCanonicalMinimizationCriteria(GrandCanonicalCriteria):\n    \"\"\"\n    Acceptance criteria for Monte Carlo moves in the grand canonical (\u03bcVT) ensemble with minimization.\n\n    This criteria extends the GrandCanonicalCriteria to include minimization of the system's energy.\n    \"\"\"\n\n    def __init__(self, optimizer: BFGSLineSearch, run_kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Initialize the GrandCanonicalMinimizationCriteria.\n        \"\"\"\n        self.optimizer = optimizer\n        self.run_kwargs = run_kwargs\n\n    def evaluate(self, *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Evaluate the acceptance criteria for a Monte Carlo move with minimization.\n\n        Parameters\n        ----------\n        *args\n            Positional arguments.\n        **kwargs\n            Keyword arguments.\n\n        Returns\n        -------\n        bool\n            True if the move is accepted, False otherwise.\n        \"\"\"\n        self.optimizer.reset()\n\n        self.optimizer.run(**self.run_kwargs)\n        return super().evaluate(*args, **kwargs)\n\n\nmc.moves[\"default_exchange_move\"].criteria = GrandCanonicalMinimizationCriteria(\n    optimizer=BFGSLineSearch(atoms, logfile=None),  # type: ignore[ase]\n    run_kwargs={\"fmax\": 0.05, \"steps\": 100},\n)\n</code></pre> <p>This criteria will run a minimization of the system before evaluating the acceptance criteria, which greatly helps in finding a suitable position for the oxygen atoms. This can be seen in the logger output:</p> <pre><code>Step Epot[eV] AcptRate Natoms\n0 -218.0509 0.000 44\n1 -227.8073 0.682 45\n2 -233.6502 0.568 46\n3 -245.7113 0.682 48\n4 -258.2237 0.659 50\n5 -276.5334 0.614 53\n6 -292.4062 0.614 56\n7 -310.4333 0.568 59\n8 -306.1936 0.545 58\n9 -324.0663 0.455 61\n10 -330.0961 0.591 62\n11 -341.8466 0.705 64\n12 -341.7592 0.591 64\n13 -356.9901 0.591 66\n14 -367.7151 0.614 68\n15 -379.8796 0.591 70\n16 -397.0771 0.523 73\n</code></pre> <p>This approach resembles a basin-hopping algorithm and unfortunately does not respect detailed balance. However, it can be useful in some cases where the acceptance rate is low and the system is not converging. A middle ground can be found by fixing every other atom and only optimizing the position of the oxygen atoms being placed, which is left as an exercise for the reader (or can be found in the <code>examples</code> directory of the <code>quansino</code> repository).</p>"},{"location":"documentation/logging.html","title":"Logging","text":"<p>Quansino differs from ASE for logging in that it does not make use of its own logging module:</p> <ul> <li>The <code>Logger</code> class is used to create custom loggers that are flexible and can be configured to log any kind of information.</li> <li>The <code>TrajectoryObserver</code> class only supports <code>extxyz</code> (<code>xyz</code>) format to log atomic trajectories.</li> <li>There is an additional <code>RestartObserver</code> class that can be used to log the entire simulation state at regular intervals for future restarts.</li> </ul> <p>All these classes are located in the <code>quansino.io</code> module and will be described in detail in the following sections.</p>"},{"location":"documentation/logging.html#the-logger-class","title":"The <code>Logger</code> class","text":"<p>The <code>Logger</code> class is designed to create custom loggers that can be configured to log various types of information. It provides a flexible interface for logging messages, warnings, and errors. The logger makes use of a dictionary called <code>fields</code> to store functions to be called when writing to the log. This allows for easy customization of the logging behavior. For example, to log the potential energy of a system, one can define the following field using the <code>add_field</code> method.</p> <pre><code>from quansino.io import Logger\n\nlogger = Logger()\nlogger.add_field(\"potential_energy\", atoms.get_potential_energy)\n</code></pre> <p><code>add_field</code>  takes a name and a function as arguments; the function should not take any arguments and should return the value to be logged.</p> <p>It is also possible to specify the format of the logged value using the <code>format</code> argument, which must be a format string compatible with Python's <code>str.format()</code> method. For example, to log the potential energy with a precision of 3 decimal places, one can do:</p> <pre><code>logger.add_field(\"potential_energy\", atoms.get_potential_energy, format=\"{:.3f}\")\n</code></pre> <p>The name provided to <code>add_field</code> will be used in the header of the logfile. The format to be used will be automatically determined based on the <code>format</code> argument, but can also be specified manually.</p> <p>Functions that return 1D arrays of values can also be logged, in which case the <code>format</code> argument must be explicitly specified to indicate how the values should be formatted. For example, to log the symbols of the atoms in the system, one can do:</p> <pre><code>atoms = ...\n\nlogger.add_field(\n    \"Symbols\",\n    atoms.get_chemical_symbols,\n    str_format=\"{:&gt;4s}\" * len(atoms),\n    header_format=f\"{{:&gt;{4 * len(atoms)}s}}\",\n    is_array=True,\n)\n\nlogger.add_field(\n    tuple(f\"Symbol[{i}]\" for i in range(len(atoms))),\n    atoms.get_chemical_symbols,\n    str_format=\"{:&gt;12s}\" * len(atoms),\n    is_array=True,\n)\n# header_format can be set to None and will be automatically generated from str_format\n</code></pre> <p>A <code>Logger</code> sent as an argument to <code>MonteCarlo</code> classes will be automatically configured to log various properties of interest, such as potential energy, forces, and stresses, depending on the simulation type. However, custom loggers manually created by the user will have to be configured manually. To this end, the <code>Logger</code> class provides convenience methods such as <code>add_md_fields</code>, <code>add_mc_fields</code>, and <code>add_opt_fields</code> to add fields that are commonly used in molecular dynamics, Monte Carlo, and optimization simulations, respectively.</p>"},{"location":"documentation/logging.html#the-trajectoryobserver-class","title":"The <code>TrajectoryObserver</code> class","text":"<p>The <code>TrajectoryObserver</code> class is used to log atomic trajectories in the <code>extxyz</code> (<code>xyz</code>) format. It provides a simple interface for writing atomic positions, velocities, and forces to a file. The trajectory can be written to a file at regular intervals during the simulation, allowing for easy analysis of the atomic motion.</p> <p>As of now, the ASE <code>Trajectory</code> writer and reader are not compatible with <code>quansino</code>. Users are encouraged to use the <code>TrajectoryObserver</code> class provided by <code>quansino</code> for logging atomic trajectories.</p>"},{"location":"documentation/logging.html#the-restartobserver-class","title":"The <code>RestartObserver</code> class","text":"<p>The <code>RestartObserver</code> class is designed to log entire simulation states at regular intervals, allowing for future restarts of the simulation. It is particularly useful for long-running simulations where one might want to save the state of the system periodically. In <code>quansino</code>, objects possess methods such as <code>to_dict</code> and <code>from_dict</code> that allow for easy serialization and deserialization of the simulation state. The <code>RestartObserver</code> class uses these methods to save the state of the simulation in JSON format, which can be easily read and written to files.</p> <pre><code>from quansino.mc.canonical import Canonical\n\nfrom ase.io.jsonio import read_json\n\nwith open(\"restart.json\", \"r\") as f:\n    data = read_json(f)\n\nmc = Canonical.from_dict(data)\n...\n</code></pre> <p>Observers are fairly flexible and files can be changed at any time during the simulation. For example, to have restart files written every 1000 steps, one can do:</p> <pre><code>mc = ...\n\nmc.add_observer(\n    \"my_restart\",\n    RestartObserver(file=\"restart.json\", interval=1000, mode=\"w\"),\n)\n\nfor step in mc.srun(10000):\n    if step % 1000 == 0:\n        mc.observers[\"my_restart\"].file = f\"restart_{mc.step_count}.json\"\n</code></pre> <p>With this setup, the simulation state will be logged at the beginning to <code>restart.json</code>, and then every 1000 steps, the file will be updated to a new file named <code>restart_1000.json</code>, <code>restart_2000.json</code>, etc. This allows for easy restarts of the simulation from the last saved state.</p>"},{"location":"documentation/logging.html#file-management","title":"File management","text":"<p>In <code>quansino</code>, file management is handled by a custom <code>FileManager</code> class that is responsible for managing the files used in the simulation. The main purpose of this class is to ensure that files are properly closed after use and to provide a consistent interface for file operations. Each <code>MonteCarlo</code> class has its own <code>FileManager</code> instance, which is used to manage the files associated with that simulation.</p> <p>In practice, when the <code>attach_observer</code> method is called on a <code>MonteCarlo</code> class, the <code>FileManager</code> instance is used to open the specified file and create an observer that will write the simulation data to that file. The <code>FileManager</code> ensures that the file is properly closed when the simulation is finished, preventing any potential data loss or corruption.</p> <p>Users are free to create their own <code>FileManager</code> instances if they need to manage files in a custom way, but in most cases, the default behavior provided by the <code>MonteCarlo</code> classes will suffice. The <code>FileManager</code> class is designed to be flexible and can be extended or modified as needed to suit specific requirements.</p> <p>Users should call the convenience method <code>close</code> to close the files managed by the <code>FileManager</code> instance. This will ensure that all data is properly written to the files and that the files are closed correctly. Note that the <code>MonteCarlo</code> classes will not automatically close the files when the simulation is finished.</p>"},{"location":"documentation/overview.html","title":"Overview","text":"<p>The <code>quansino</code> package allows you to easily create flexible and modular Monte Carlo simulations in Python. Below is an overview of the main concepts and components of the package.</p>"},{"location":"documentation/overview.html#the-montecarlo-class","title":"The <code>MonteCarlo</code> Class","text":"<p>The <code>MonteCarlo</code> class is the core of the <code>quansino</code> package. The role of this class is to manage the simulation process, including:</p> <ul> <li>Initializing the simulation with a set of parameters.</li> <li>Running the simulation for a specified number of iterations or convergence criteria.</li> <li>Managing the observers and their potential files.</li> <li>Yielding the move that are going to be run.</li> </ul> <p>In <code>quansino</code>, a simulation can be summarized via the following pseudo-code:</p> <pre><code>iterate over steps:\n    iterate over moves:\n        perform move\n        evaluate criteria\n        save or revert state\n\n    call observers\n\n    if \"converged\":\n        stop\n    else:\n        continue to next step\n</code></pre> <p>This skeleton is what is run when you call the <code>run</code> method of the <code>MonteCarlo</code> class. The method call the <code>step</code> method, <code>max_steps</code> times, which in turn calls the <code>yield_moves</code> method to select the moves to be performed. At the end of each step, the observers are called to perform their actions, such as saving the state or logging information.</p> <p>Convenience methods such as <code>irun</code> or <code>srun</code> are provided to run the simulation with more or less flexibility:</p> <pre><code>for steps in mc.srun(max_steps=1000):\n    pass\n    # Any custom code here will be run after each step, before observers are called\n\nfor steps in mc.irun(max_steps=1000):\n    for move_name in steps:\n        pass\n        # Any custom code here will be run before each move is performed\n\n        # Any custom code here will be run after each step, before observers are called\n</code></pre> <p>Users seeking even more flexibility are free to subclass the <code>MonteCarlo</code> class and override the <code>step</code> and <code>yield_moves</code> methods to implement custom logic.</p> <p>To perform the simulation, the <code>MonteCarlo</code> class calls multiple objects each aiming to perform a specific task. These objects will be described in the following sections.</p>"},{"location":"documentation/overview.html#move-classes","title":"<code>Move</code> Classes","text":"<p><code>Move</code> classes are responsible for defining actions that can be performed during the simulation. Each move when called perform geometric, exchange, or other types of operations on the system. The <code>Move</code> class is defined as a <code>Protocol</code>, allowing users to create their custom classes, and pass them in the Monte Carlo simulation, which take the <code>Move</code> protocol as a Generic Type.</p> <p>For a more focused approach, the package provide the <code>BaseMove</code> class and their subclasses, such as <code>DisplacementMove</code>, <code>ExchangeMove</code>, and <code>CellMove</code>.</p> <p>Each of these move classes implements the <code>__call__</code> method, which is invoked during the simulation to perform the move. In the case of <code>DisplacementMove</code>, it will attempt to displace a particle selected randomly from the system. These behaviors are heavily tunable and can be customized by passing parameters to the move classes.</p> <pre><code>from quansino.moves import DisplacementMove\n\nmove = DisplacementMove(\n    labels=[0, 1, 1, 2, 2, 2, -1, -1],\n    operation=Ball(0.1),\n    apply_constraints=True,  # ASE constraints will be applied when performing the move.\n)  # This move will attempt to displace one particle each time it is called.\n</code></pre> <p>Warning</p> <p>The word \"particle\" is used as a general term to refer to any entity in the simulation that is considered a single unit, such as a single atom, molecules, or other entities. In the above example, the labels represent which atoms are grouped together as a \"particle\". Atoms with the same label are considered part of the same particle, and the move will move the entire particle as a single unit, allowing molecular displacements.</p> <p><code>Operations</code> will be detailed in the next section, but it is important to note that it defines the action that will be performed on the particle. In this case, <code>Ball(0.1)</code> will displace the particle by a random distance of maximum 0.1 \u00c5 in a ball around the particle's current position.</p> <p>If users want to move multiple particles at once (per criteria), or perform more complex actions, they can simply add moves together:</p> <pre><code>from quansino.moves import DisplacementMove, ExchangeMove\n\n# Create a move that will attempt to displace one particle and add/remove another particle\nweird_move = DisplacementMove(...) + ExchangeMove(...)\n\n# Multiplication is also supported, allowing to repeat the same move multiple times\nmulti_displacement_move = (\n    DisplacementMove(...) * 10\n)  # Will attempt to displace 10 particles per criteria\n</code></pre>"},{"location":"documentation/overview.html#operation-classes","title":"<code>Operation</code> Classes","text":"<p><code>Operations</code> based classes define the specific actions that can be performed on the system during the simulation. The <code>Operation</code> class is also defined as a <code>Protocol</code>, allowing users to easily create custom operations. Sensible defaults are provided in the package, such as <code>Ball</code>, <code>Box</code>, <code>Sphere</code>. Most of the time these classes only define a single <code>calculate</code> method, which takes a <code>Context</code> as an argument and returns the displacement/deformation vector to be applied to the particle/box.</p> <pre><code>from quansino.operations import Ball, Translation\n\noperation = Ball(\n    0.1\n)  # Displaces particles by a random distance of maximum 0.1 Angstroms in a ball around the particle's current position\n\ndisplacement_vector = operation.calculate(\n    ...\n)  # Returns a random displacement vector used in the move.\n\noperation = Translation()  # Translates particles randomly in the unit cell.\n</code></pre> <p>Most of the time, operations are used in the <code>__call__</code> method of the <code>Move</code> class, and is checked against a user-defined criteria <code>check_move</code> <code>Callable</code> attribute. This can be used to define constraints, such as ensuring that particles do not overlap or go outside of a defined box. By default, operations are attempted a limited amount times, and the first successful one is used. This can be customized by modifying the <code>max_attempts</code> attribute of the <code>BaseMove</code> class.</p>"},{"location":"documentation/overview.html#criteria-classes","title":"<code>Criteria</code> Classes","text":"<p><code>Criteria</code> based classes are used to evaluate whether a move is successful or not. They define the conditions that must be met for a move to be accepted. The <code>Criteria</code> class is also defined as a <code>Protocol</code>, allowing users to create custom criteria. When adding a move to a simulation, the criteria can be passed as well. The package provides several built-in criteria, such as <code>CanonicalCriteria</code>, <code>GrandCanonicalCriteria</code>, and <code>IsobaricCriteria</code>. These classes implement the <code>evaluate</code> method, which takes the context as argument.</p> <pre><code>from quansino.mc.criteria import CanonicalCriteria\n\ncriteria = CanonicalCriteria()\n\ncriteria.evaluate(context)  # Returns True if the move is accepted, False otherwise\n</code></pre>"},{"location":"documentation/overview.html#context-class","title":"<code>Context</code> Class","text":"<p>The <code>Context</code> class provides the necessary information about the current state of the simulation. It encapsulates all relevant data that may be needed by moves, operations, and criteria to make decisions. This includes information about the system's configuration, (Atoms object), temperature, pressure, and other simulation parameters. The <code>Context</code> class lives both in the <code>MonteCarlo</code> class and in the <code>Move</code> class, allowing to access the context from both places. The context is passed to <code>Operations</code> and <code>Criteria</code> classes when they are called, allowing them to access the necessary information to perform their actions.</p> <p>Each kind of simulation (e.g., canonical, grand canonical) have its own context (see <code>DisplacementContext</code>, <code>DeformationContext</code>, etc.) which is initialized with the relevant parameters.</p> <p>Danger</p> <p><code>Context</code> based classes are not meant to be modified by users. It is used internally by the package to manage the state of the simulation. Unless you are implementing a custom move, operation, or criteria, that requires additional information to be passed, you should not need to interact with the <code>Context</code> class directly. Instead, you can rely on the methods provided by the <code>MonteCarlo</code> class to access the necessary information.</p> <p>Find below a diagram summarizing the relationships between the main classes in the <code>quansino</code> package:</p> <pre><code>classDiagram\n  Criteria &lt;-- MonteCarlo\n  Move &lt;-- MonteCarlo\n  Context &lt;-- MonteCarlo\n  class MonteCarlo{\n    context\n    moves[MoveType, CriteriaType]\n    add_move(move, criteria, name, interval, probability)\n    run(max_steps)\n    step()\n    yield_moves()\n  }\n  class Context{\n    atoms\n    rng\n  }\n  class Move{\n    __call__(context)\n  }\n  class Criteria{\n    evaluate(context)\n  }\n  class Operation{\n    calculate(context)\n  }\n  Operation &lt;-- Move</code></pre>"},{"location":"documentation/overview.html#summary","title":"Summary","text":"<p>Gathering the information from the previous sections, a typical simulation setup in <code>quansino</code> would look like this:</p> <pre><code>import numpy as np\n\nfrom quansino.mc import Canonical\nfrom quansino.moves import DisplacementMove, ExchangeMove\nfrom quansino.operations import Ball\nfrom quansino.mc.criteria import CanonicalCriteria\n\nfrom ase.build import bulk\n\natoms = bulk(\"Cu\", \"fcc\", cubic=True)\n\natoms.calc = ...\n\nmc = Canonical(atoms, temperature=300, max_cycles=len(atoms), seed=42)\n\nmove = DisplacementMove(\n    labels=np.arange(len(atoms)),\n    operation=Ball(0.1),\n)\n\nmc.add_move(\n    move,\n    criteria=CanonicalCriteria(),\n    name=\"displacement_move\",\n    interval=1,\n    probability=1.0,\n)\n\nfor steps in mc.irun(1000):\n    for move_name in steps:  # &lt;-- len(atoms) cycles.\n        print(f\"Performed move: {move_name}\")\n\n# Alternatively:\nmc.run(1000)\n</code></pre>"},{"location":"installation/install.html","title":"Install","text":"<p>The <code>quansino</code> package requires Python 3.12+ and can be installed directly from PyPI using the <code>pip</code> command:</p> <pre><code>pip install quansino\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quansino<ul> <li>constraints</li> <li>integrators<ul> <li>core</li> <li>displacement</li> </ul> </li> <li>io<ul> <li>core</li> <li>file</li> <li>logger</li> <li>restart</li> <li>trajectory</li> </ul> </li> <li>mc<ul> <li>canonical</li> <li>contexts</li> <li>core</li> <li>criteria</li> <li>driver</li> <li>fbmc</li> <li>gcmc</li> <li>isobaric</li> <li>isotension</li> </ul> </li> <li>moves<ul> <li>cell</li> <li>composite</li> <li>core</li> <li>displacement</li> <li>exchange</li> </ul> </li> <li>operations<ul> <li>cell</li> <li>composite</li> <li>core</li> <li>displacement</li> </ul> </li> <li>protocols</li> <li>registry</li> <li>type_hints</li> <li>utils<ul> <li>atoms</li> <li>dynamics</li> <li>moves</li> <li>strings</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quansino/constraints.html","title":"constraints","text":"<p>Module containing additional constraints classes</p>"},{"location":"reference/quansino/constraints.html#quansino.constraints.FixRot","title":"FixRot","text":"<p>               Bases: <code>FixConstraint</code></p> <p>Constraint class to remove the rotation of the system by subtracting the angular momentum from the momenta. Only to use with free boundary conditions, this constraint is not compatible with periodic boundary conditions.</p>"},{"location":"reference/quansino/constraints.html#quansino.constraints.FixRot.adjust_momenta","title":"adjust_momenta","text":"<pre><code>adjust_momenta(atoms, momenta)\n</code></pre> <p>Adjust the momenta of the atoms to remove angular momentum.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to adjust the angular momentum for.</p> </li> <li> <code>momenta</code>               (<code>Momenta</code>)           \u2013            <p>The momenta of the atoms to be adjusted.</p> </li> </ul> Source code in <code>quansino/constraints.py</code> <pre><code>def adjust_momenta(self, atoms: Atoms, momenta: Momenta) -&gt; None:\n    \"\"\"\n    Adjust the momenta of the atoms to remove angular momentum.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The atoms object to adjust the angular momentum for.\n    momenta : Momenta\n        The momenta of the atoms to be adjusted.\n    \"\"\"\n    positions_to_com = atoms.positions - atoms.get_center_of_mass()\n\n    eig, vecs = atoms.get_moments_of_inertia(vectors=True)\n\n    inv_inertia = np.linalg.inv(np.linalg.inv(vecs) @ np.diag(eig) @ vecs)\n    angular_momentum = np.sum(np.cross(positions_to_com, momenta), axis=0)\n\n    omega = inv_inertia @ angular_momentum\n\n    correction = np.cross(omega, positions_to_com)\n\n    masses = atoms.get_masses()\n\n    momenta[:] = momenta - correction * masses[:, None]\n</code></pre>"},{"location":"reference/quansino/constraints.html#quansino.constraints.FixRot.get_removed_dof","title":"get_removed_dof","text":"<pre><code>get_removed_dof(*_args, **_kwargs)\n</code></pre> <p>Get the number of degrees of freedom removed by the <code>FixRot</code> constraint.</p> <p>Returns:</p> <ul> <li> <code>Literal[3]</code>           \u2013            <p>The number of degrees of freedom removed by the <code>FixRot</code> constraint, which is always 3.</p> </li> </ul> Source code in <code>quansino/constraints.py</code> <pre><code>def get_removed_dof(self, *_args: Any, **_kwargs: Any) -&gt; Literal[3]:\n    \"\"\"\n    Get the number of degrees of freedom removed by the [`FixRot`][quansino.constraints.FixRot] constraint.\n\n    Returns\n    -------\n    Literal[3]\n        The number of degrees of freedom removed by the [`FixRot`][quansino.constraints.FixRot] constraint, which is always 3.\n    \"\"\"\n    return 3\n</code></pre>"},{"location":"reference/quansino/constraints.html#quansino.constraints.FixRot.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>FixRot</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>FixRot</code> object.</p> </li> </ul> Source code in <code>quansino/constraints.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the [`FixRot`][quansino.constraints.FixRot] object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the [`FixRot`][quansino.constraints.FixRot] object.\n    \"\"\"\n    return {\"name\": \"FixRot\", \"kwargs\": {}}\n</code></pre>"},{"location":"reference/quansino/protocols.html","title":"protocols","text":""},{"location":"reference/quansino/protocols.html#quansino.protocols.Criteria","title":"Criteria","text":"<p>               Bases: <code>Serializable</code>, <code>Protocol</code>, <code>Generic[ContextType]</code></p> <p>Base protocol for all criteria in <code>MonteCarlo</code> simulations. Criteria are used to evaluate whether a move is acceptable based on the current state of the system. Criteria classes should implement the <code>evaluate</code> method to perform the evaluation and return a boolean indicating whether the criteria are met. Such method take a simulation <code>Context</code> as parameter, which provides the necessary information about the current state of the system, such as atom positions, cell parameters, as well as any additional information needed to perform the evaluation.</p>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Criteria.evaluate","title":"evaluate","text":"<pre><code>evaluate(context)\n</code></pre> <p>Calculate the operation to perform based on the given context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the criteria are met for the current context.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def evaluate(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Calculate the operation to perform based on the given context.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context to use when calculating the operation.\n\n    Returns\n    -------\n    bool\n        Whether the criteria are met for the current context.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Integrator","title":"Integrator","text":"<p>               Bases: <code>Serializable</code>, <code>Protocol</code>, <code>Generic[ContextType]</code></p> <p>Base protocol for all integrators in <code>MonteCarlo</code> simulations. Integrators are used to update the state of the system in place based on the current context and the operations performed. Integrator classes should implement the <code>integrate</code> method to perform the integration step. Such method take a simulation <code>Context</code> as parameter, which provides the necessary information about the current state of the system, such as atom positions, cell parameters, as well as any additional information needed to perform the integration.</p>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Integrator.integrate","title":"integrate","text":"<pre><code>integrate(context)\n</code></pre> <p>Perform the integration step based on the current context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context to use when performing the integration step.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def integrate(self, context: ContextType) -&gt; None:\n    \"\"\"\n    Perform the integration step based on the current context.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context to use when performing the integration step.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Move","title":"Move","text":"<p>               Bases: <code>Serializable</code>, <code>Protocol</code>, <code>Generic[ContextType]</code></p> <p>Base protocol for all acceptable moves in <code>MonteCarlo</code> simulations. Moves perform specific tasks such as displacing atoms, deforming cells, or exchanging atoms. Move classes should implement the <code>__call__</code> method to perform the move and return whether it was successful. Such method take a simulation <code>Context</code> as parameter, which provides the necessary information about the current state of the system, such as atom positions, cell parameters, as well as any additional information needed to perform the move.</p>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Move.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the move, i.e. displace, deform cells, or exchange atoms, in place. This method should be implemented in user defined classes, and should return a boolean indicating whether the attempted operation was successful. Users are free to implement their own contraints and logic for what constitutes a successful move. Criteria for success can include whether the move results in a valid configuration, and should typically involve geometric (regions, distances between atoms, ...) constraints. Energy constraints should not be used here, as they are typically handled by <code>Criteria</code> classes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was successful.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def __call__(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Perform the move, i.e. displace, deform cells, or exchange atoms, in place. This method should be implemented in user defined classes, and should return a boolean indicating whether the attempted operation was successful. Users are free to implement their own contraints and logic for what constitutes a successful move. Criteria for success can include whether the move results in a valid configuration, and should typically involve geometric (regions, distances between atoms, ...) constraints. Energy constraints should not be used here, as they are typically handled by [`Criteria`][quansino.protocols.Criteria] classes.\n\n    Returns\n    -------\n    bool\n        Whether the move was successful.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Move.on_atoms_changed","title":"on_atoms_changed","text":"<pre><code>on_atoms_changed(added_indices, removed_indices)\n</code></pre> <p>Function to run when atoms are added or removed from the simulation. This method should be implemented in user defined move classes to update the move's internal state based on the changes in atoms.</p> <p>Parameters:</p> <ul> <li> <code>added_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms that were added.</p> </li> <li> <code>removed_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms that were removed.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def on_atoms_changed(\n    self, added_indices: IntegerArray, removed_indices: IntegerArray\n) -&gt; None:\n    \"\"\"\n    Function to run when atoms are added or removed from the simulation. This method should be implemented in user defined move classes to update the move's internal state based on the changes in atoms.\n\n    Parameters\n    ----------\n    added_indices : IntegerArray\n        The indices of the atoms that were added.\n    removed_indices : IntegerArray\n        The indices of the atoms that were removed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Move.on_cell_changed","title":"on_cell_changed","text":"<pre><code>on_cell_changed(new_cell)\n</code></pre> <p>Function to run when the cell changes. This method should be implemented in user defined move classes to update the move's internal state based on the new cell.</p> <p>Parameters:</p> <ul> <li> <code>new_cell</code>               (<code>Cell</code>)           \u2013            <p>The new cell.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def on_cell_changed(self, new_cell: Cell) -&gt; None:\n    \"\"\"\n    Function to run when the cell changes. This method should be implemented in user defined move classes to update the move's internal state based on the new cell.\n\n    Parameters\n    ----------\n    new_cell : Cell\n        The new cell.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Operation","title":"Operation","text":"<p>               Bases: <code>Serializable</code>, <code>Protocol</code>, <code>Generic[ContextType]</code></p> <p>Base protocol for all operations in <code>MonteCarlo</code> simulations. Operations are used by <code>Move</code> to calculate various operations, such as calculating displacements or deformation tensors. Operation classes should implement the <code>calculate</code> method to perform the operation and return the result. Such method take a simulation <code>Context</code> as parameter, which provides the necessary information about the current state of the system, such as atom positions, cell parameters, as well as any additional information needed to perform the operation.</p>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Operation.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate the operation to perform based on the given context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the calculation, typically a displacement or strain tensor.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def calculate(self, context: ContextType) -&gt; Any:\n    \"\"\"\n    Calculate the operation to perform based on the given context.\n\n    Parameters\n    ----------\n    context : Context\n        The context to use when calculating the operation.\n\n    Returns\n    -------\n    Any\n        The result of the calculation, typically a displacement or strain tensor.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Serializable","title":"Serializable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can be serialized to and from a dictionary.</p>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Serializable.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create an object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create an object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the object.\n\n    Returns\n    -------\n    Self\n        The object created from the dictionary.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/protocols.html#quansino.protocols.Serializable.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the object.</p> </li> </ul> Source code in <code>quansino/protocols.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/registry.html","title":"registry","text":"<p>Module for Class registry serialization/deserialization of simulation objects.</p> <p>This module essentially provides a way to register classes with a name, retrieve them by name. This is useful for serialization and deserialization of custom simulation objects, allowing them to be stored and retrieved without needing to know their exact class at runtime. Users can register their custom classes in their code, which will then be available globally for serialization and deserialization purposes via their <code>__class__.__name__</code> attribute.</p> <p>Users should avoid using the <code>__class_registry</code> global variable directly, and instead use the provided functions to register and retrieve classes. This ensures that the registry is used correctly and avoids potential issues with bad scoping or name collisions.</p>"},{"location":"reference/quansino/registry.html#quansino.registry.get_class","title":"get_class","text":"<pre><code>get_class(class_name)\n</code></pre> <p>Get a class by its registered name.</p> <p>Parameters:</p> <ul> <li> <code>class_name</code>               (<code>str</code>)           \u2013            <p>The name of the class to get.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type</code>           \u2013            <p>The class registered with the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the class is not registered.</p> </li> </ul> Source code in <code>quansino/registry.py</code> <pre><code>def get_class(class_name: str) -&gt; type:\n    \"\"\"\n    Get a class by its registered name.\n\n    Parameters\n    ----------\n    class_name : str\n        The name of the class to get.\n\n    Returns\n    -------\n    type\n        The class registered with the given name.\n\n    Raises\n    ------\n    KeyError\n        If the class is not registered.\n    \"\"\"\n    if class_name not in __class_registry:\n        raise KeyError(\n            f\"Class `{class_name}` not registered in the global registry. Available classes: {list(__class_registry.keys())}\"\n        )\n\n    return __class_registry[class_name]\n</code></pre>"},{"location":"reference/quansino/registry.html#quansino.registry.get_class_name","title":"get_class_name","text":"<pre><code>get_class_name(cls)\n</code></pre> <p>Get the registered name of a class.</p> <p>Parameters:</p> <ul> <li> <code>cls</code>               (<code>type</code>)           \u2013            <p>The class to get the name of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The registered name of the class, or None if not found.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the class is not registered.</p> </li> </ul> Source code in <code>quansino/registry.py</code> <pre><code>def get_class_name(cls: type) -&gt; str:\n    \"\"\"\n    Get the registered name of a class.\n\n    Parameters\n    ----------\n    cls : type\n        The class to get the name of.\n\n    Returns\n    -------\n    str\n        The registered name of the class, or None if not found.\n\n    Raises\n    ------\n    KeyError\n        If the class is not registered.\n    \"\"\"\n    for name, registered_cls in __class_registry.items():\n        if registered_cls is cls:\n            return name\n\n    raise KeyError(\n        f\"Class `{cls.__name__}` not found in the global registry. Available classes: {list(__class_registry.values())}\"\n    )\n</code></pre>"},{"location":"reference/quansino/registry.html#quansino.registry.get_typed_class","title":"get_typed_class","text":"<pre><code>get_typed_class(name, expected_base)\n</code></pre> <p>Get a class by its registered name with runtime type checking.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the class to get.</p> </li> <li> <code>expected_base</code>               (<code>type</code>)           \u2013            <p>The base class that the returned class should inherit from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type</code>           \u2013            <p>The class registered with the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the registered class is not a subclass of expected_base.</p> </li> </ul> Source code in <code>quansino/registry.py</code> <pre><code>def get_typed_class(name: str, expected_base: type) -&gt; type:\n    \"\"\"\n    Get a class by its registered name with runtime type checking.\n\n    Parameters\n    ----------\n    name : str\n        The name of the class to get.\n    expected_base : type\n        The base class that the returned class should inherit from.\n\n    Returns\n    -------\n    type\n        The class registered with the given name.\n\n    Raises\n    ------\n    TypeError\n        If the registered class is not a subclass of expected_base.\n    \"\"\"\n    cls = get_class(name)\n\n    if not issubclass(cls, expected_base):\n        raise TypeError(\n            f\"Class `{name}` is not a {expected_base.__name__} subclass. Got {cls.__name__} instead.\"\n        )\n\n    return cls\n</code></pre>"},{"location":"reference/quansino/registry.html#quansino.registry.register","title":"register","text":"<pre><code>register(class_name=None)\n</code></pre> <p>Decorator to register a class with a name.</p> <p>Parameters:</p> <ul> <li> <code>class_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name to register the class with, by default None. If None, <code>cls.__name__</code> is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[type], type]</code>           \u2013            <p>A decorator that registers the class with the given name.</p> </li> </ul> Source code in <code>quansino/registry.py</code> <pre><code>def register(class_name: str | None = None) -&gt; Callable[[type], type]:\n    \"\"\"\n    Decorator to register a class with a name.\n\n    Parameters\n    ----------\n    class_name : str | None, optional\n        The name to register the class with, by default None. If None, `cls.__name__` is used.\n\n    Returns\n    -------\n    Callable[[type], type]\n        A decorator that registers the class with the given name.\n    \"\"\"\n\n    def decorator(cls: type) -&gt; type:\n        \"\"\"\n        Decorator function to register a class with a name\n        when the class is defined.\n\n        Parameters\n        ----------\n        cls : type\n            The class to register.\n\n        Returns\n        -------\n        type\n            The registered class.\n        \"\"\"\n        return register_class(cls, class_name)\n\n    return decorator\n</code></pre>"},{"location":"reference/quansino/registry.html#quansino.registry.register_class","title":"register_class","text":"<pre><code>register_class(cls, class_name=None)\n</code></pre> <p>Register a class with a name directly (non-decorator version).</p> <p>Parameters:</p> <ul> <li> <code>cls</code>               (<code>type</code>)           \u2013            <p>The class to register.</p> </li> <li> <code>class_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name to register the class with, by default None. If None, <code>cls.__name__</code> is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type</code>           \u2013            <p>The registered class.</p> </li> </ul> Source code in <code>quansino/registry.py</code> <pre><code>def register_class(cls: type, class_name: str | None = None) -&gt; type:\n    \"\"\"\n    Register a class with a name directly (non-decorator version).\n\n    Parameters\n    ----------\n    cls : type\n        The class to register.\n    class_name : str | None, optional\n        The name to register the class with, by default None. If None, `cls.__name__` is used.\n\n    Returns\n    -------\n    type\n        The registered class.\n    \"\"\"\n    if class_name is None:\n        class_name = cls.__name__\n\n    __class_registry[class_name] = cls\n\n    return cls\n</code></pre>"},{"location":"reference/quansino/type_hints.html","title":"type_hints","text":"<p>Module for type hints.</p> <p>This module provides semantic type hints for various data structures used throughout the quansino package. These type aliases improve code readability by clearly defining the expected data types, their intended scientific meaning, and their expected shapes.</p> Note <p>Current Python type checkers cannot enforce numpy array shape constraints. These type hints provide semantic clarity and documentation until native shape typing becomes available in future Python versions without relying on third-party libraries.</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.AdjacencyMatrix","title":"AdjacencyMatrix  <code>module-attribute</code>","text":"<pre><code>AdjacencyMatrix = NDArray[integer]\n</code></pre> <p>2D-Array representing an adjacency matrix with shape (N, N).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.AtomicNumbers","title":"AtomicNumbers  <code>module-attribute</code>","text":"<pre><code>AtomicNumbers = NDArray[integer]\n</code></pre> <p>1D-Array of atomic numbers with shape (N,).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Center","title":"Center  <code>module-attribute</code>","text":"<pre><code>Center = list[float] | tuple[float] | NDArray[floating]\n</code></pre> <p>1D-Array representing center point with shape (3,).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Deformation","title":"Deformation  <code>module-attribute</code>","text":"<pre><code>Deformation = NDArray[floating]\n</code></pre> <p>2D-Array representing a deformation gradient tensor with shape (3, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Displacement","title":"Displacement  <code>module-attribute</code>","text":"<pre><code>Displacement = NDArray[floating]\n</code></pre> <p>2D-Array representing a displacement vector with shape (3,) or (1, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Displacements","title":"Displacements  <code>module-attribute</code>","text":"<pre><code>Displacements = NDArray[floating]\n</code></pre> <p>2D-Array of displacements with shape (N, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Forces","title":"Forces  <code>module-attribute</code>","text":"<pre><code>Forces = NDArray[floating]\n</code></pre> <p>2D-Array of forces with shape (N, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.IntegerArray","title":"IntegerArray  <code>module-attribute</code>","text":"<pre><code>IntegerArray = list[int] | tuple[int] | NDArray[integer]\n</code></pre> <p>1D-Array of integers with shape (N,).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Masses","title":"Masses  <code>module-attribute</code>","text":"<pre><code>Masses = NDArray[floating]\n</code></pre> <p>1D-Array of masses with shape (N,).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Momenta","title":"Momenta  <code>module-attribute</code>","text":"<pre><code>Momenta = NDArray[floating]\n</code></pre> <p>2D-Array of momenta with shape (N, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Positions","title":"Positions  <code>module-attribute</code>","text":"<pre><code>Positions = NDArray[floating]\n</code></pre> <p>2D-Array of atomic positions with shape (N, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.ShapedMasses","title":"ShapedMasses  <code>module-attribute</code>","text":"<pre><code>ShapedMasses = NDArray[floating]\n</code></pre> <p>2D-Array of masses with shape (N, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Strain","title":"Strain  <code>module-attribute</code>","text":"<pre><code>Strain = NDArray[floating]\n</code></pre> <p>Array representing a strain tensor with shape (6,) or (3, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Stress","title":"Stress  <code>module-attribute</code>","text":"<pre><code>Stress = NDArray[floating]\n</code></pre> <p>Array representing a stress tensor with shape (6,) or (3, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.UnitCell","title":"UnitCell  <code>module-attribute</code>","text":"<pre><code>UnitCell = NDArray[floating]\n</code></pre> <p>2D-Array representing a cell matrix with shape (3, 3).</p>"},{"location":"reference/quansino/type_hints.html#quansino.type_hints.Velocities","title":"Velocities  <code>module-attribute</code>","text":"<pre><code>Velocities = NDArray[floating]\n</code></pre> <p>2D-Array representing velocities with shape (N, 3).</p>"},{"location":"reference/quansino/integrators/core.html","title":"core","text":""},{"location":"reference/quansino/integrators/core.html#quansino.integrators.core.BaseIntegrator","title":"BaseIntegrator","text":"<p>Abstract base class for integrators in Monte Carlo simulations.</p> <p>This class defines the interface for all integrators that can be used to perform operations on a simulation context. Integrators can be used to perform dynamical operations such as integration of equations of motion or other time-dependent processes.</p>"},{"location":"reference/quansino/integrators/core.html#quansino.integrators.core.BaseIntegrator.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create an <code>BaseIntegrator</code> object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the <code>BaseIntegrator</code> object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BaseIntegrator</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/integrators/core.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create an `BaseIntegrator` object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the `BaseIntegrator` object.\n\n    Returns\n    -------\n    Self\n        The `BaseIntegrator` object created from the dictionary.\n    \"\"\"\n    kwargs = data.get(\"kwargs\", {})\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/integrators/core.html#quansino.integrators.core.BaseIntegrator.integrate","title":"integrate","text":"<pre><code>integrate(context, *args, **kwargs)\n</code></pre> <p>Integrate the equations of motion based on the given context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context to use when calculating the integrator.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Additional positional arguments for the integrator.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the integrator.</p> </li> </ul> Source code in <code>quansino/integrators/core.py</code> <pre><code>def integrate(self, context: Context, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Integrate the equations of motion based on the given context.\n\n    Parameters\n    ----------\n    context : Context\n        The context to use when calculating the integrator.\n    *args: Any\n        Additional positional arguments for the integrator.\n    **kwargs: Any\n        Additional keyword arguments for the integrator.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/integrators/core.html#quansino.integrators.core.BaseIntegrator.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>BaseIntegrator</code> object to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The dictionary representation of the <code>BaseIntegrator</code> object.</p> </li> </ul> Source code in <code>quansino/integrators/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `BaseIntegrator` object to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        The dictionary representation of the `BaseIntegrator` object.\n    \"\"\"\n    return {\"name\": self.__class__.__name__}\n</code></pre>"},{"location":"reference/quansino/integrators/displacement.html","title":"displacement","text":""},{"location":"reference/quansino/integrators/displacement.html#quansino.integrators.displacement.Verlet","title":"Verlet","text":"<pre><code>Verlet(dt=1.0, max_steps=100, apply_constraints=True)\n</code></pre> <p>               Bases: <code>BaseIntegrator</code></p> <p>Class for a Verlet operation that displaces atoms based on their forces.</p> <p>This operation uses the Verlet algorithm to displace atoms based on their forces, scaled by a delta factor and adjusted by the masses of the atoms.</p> <p>Parameters:</p> <ul> <li> <code>delta</code>               (<code>float</code>)           \u2013            <p>The scaling factor for the displacement (default is 1.0).</p> </li> <li> <code>masses_scaling_power</code>               (<code>float</code>)           \u2013            <p>The power to which the masses are raised for scaling (default is 0.5).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector for the selected atoms based on their forces.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dt</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The time step for the integration in femtoseconds, by default 1.0 fs.</p> </li> <li> <code>max_steps</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The maximum number of steps to perform in the integration, by default 100.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints during the integration, by default True.</p> </li> </ul> Source code in <code>quansino/integrators/displacement.py</code> <pre><code>def __init__(\n    self, dt: float = 1.0, max_steps: int = 100, apply_constraints: bool = True\n) -&gt; None:\n    \"\"\"\n    Initialize the `Verlet` integrator.\n\n    Parameters\n    ----------\n    dt : float, optional\n        The time step for the integration in femtoseconds, by default 1.0 fs.\n    max_steps : int, optional\n        The maximum number of steps to perform in the integration, by default 100.\n    apply_constraints : bool, optional\n        Whether to apply constraints during the integration, by default True.\n    \"\"\"\n    self.dt = dt * fs\n    self.max_steps = max_steps\n    self.apply_constraints = apply_constraints\n</code></pre>"},{"location":"reference/quansino/integrators/displacement.html#quansino.integrators.displacement.Verlet.integrate","title":"integrate","text":"<pre><code>integrate(context)\n</code></pre> <p>Perform a single step of the Velocity Verlet integration.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The simulation context containing the atoms.</p> </li> </ul> Source code in <code>quansino/integrators/displacement.py</code> <pre><code>def integrate(self, context: DisplacementContext) -&gt; None:\n    \"\"\"\n    Perform a single step of the Velocity Verlet integration.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The simulation context containing the atoms.\n    \"\"\"\n    atoms = context.atoms\n    masses = atoms.get_masses()[:, None]\n    forces = atoms.get_forces()\n\n    for _ in range(self.max_steps):\n        new_momenta = atoms.get_momenta() + 0.5 * forces * self.dt\n\n        positions = atoms.get_positions()\n        atoms.set_positions(\n            positions + new_momenta / masses * self.dt,\n            apply_constraint=self.apply_constraints,\n        )\n\n        if self.apply_constraints:\n            new_momenta = (atoms.positions - positions) * masses / self.dt\n\n        forces = atoms.get_forces()\n        atoms.set_momenta(\n            new_momenta + 0.5 * forces * self.dt,\n            apply_constraint=self.apply_constraints,\n        )\n</code></pre>"},{"location":"reference/quansino/io/core.html","title":"core","text":""},{"location":"reference/quansino/io/core.html#quansino.io.core.Observer","title":"Observer","text":"<pre><code>Observer(interval=1)\n</code></pre> <p>Base class for observers which are used to monitor and record the state of the simulation at specified intervals.</p> <p>Parameters:</p> <ul> <li> <code>interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The interval at which the observer will be called, by default 1.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>interval</code>               (<code>int</code>)           \u2013            <p>The interval at which the observer will be called.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def __init__(self, interval: int = 1) -&gt; None:\n    \"\"\"Initialize the `Observer` object.\"\"\"\n    self.interval = interval\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.Observer.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call the observer with the given arguments. This method should be overridden by subclasses to implement specific behavior.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments passed to the observer.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments passed to the observer.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>@abstractmethod\ndef __call__(self, *args: Any, **kwargs: Any):\n    \"\"\"\n    Call the observer with the given arguments. This method should be overridden by subclasses to implement specific behavior.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments passed to the observer.\n    **kwargs : Any\n        Keyword arguments passed to the observer.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.Observer.attach_simulation","title":"attach_simulation  <code>abstractmethod</code>","text":"<pre><code>attach_simulation(*args, **kwargs)\n</code></pre> <p>Attach a simulation to the observer. This method should be overridden by subclasses to implement specific attachment behavior.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments passed to the observer.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments passed to the observer.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>@abstractmethod\ndef attach_simulation(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Attach a simulation to the observer. This method should be overridden by subclasses to implement specific attachment behavior.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments passed to the observer.\n    **kwargs : Any\n        Keyword arguments passed to the observer.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.Observer.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>Observer</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>Observer</code> object.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `Observer` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `Observer` object.\n    \"\"\"\n    return {\"name\": self.__class__.__name__, \"kwargs\": {\"interval\": self.interval}}\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver","title":"TextObserver","text":"<pre><code>TextObserver(file, interval=1, mode='a', encoding=None)\n</code></pre> <p>               Bases: <code>Observer</code></p> <p>Base class for text-based observers in a simulation. <code>TextObservers</code> are used to write output to a file or stream at specified intervals.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>IO | Path | str</code>)           \u2013            <p>The file or stream to write output to. This can be a file object, a string representing a file path, or a <code>Path</code> object.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The interval at which the observer will be called, by default 1.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>The mode in which to open the file, by default \"a\".</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The encoding to use when opening the file, by default None. If None, default to 'utf-8' for text files stays None for binary files.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>accept_stream</code>               (<code>bool</code>)           \u2013            <p>Whether the observer accepts a stream of data.</p> </li> <li> <code>file</code>               (<code>IO</code>)           \u2013            <p>The file or stream to write output to.</p> </li> <li> <code>mode</code>               (<code>str</code>)           \u2013            <p>The mode in which to open the file.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>)           \u2013            <p>The encoding to use when opening the file.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def __init__(\n    self,\n    file: IO | Path | str,\n    interval: int = 1,\n    mode: str = \"a\",\n    encoding: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the `TextObserver` object.\"\"\"\n    super().__init__(interval)\n\n    self.mode: str = mode\n    self.encoding: str | None = encoding or (\"utf-8\" if \"b\" not in mode else None)\n\n    self.file = file\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.file","title":"file  <code>property</code> <code>writable</code>","text":"<pre><code>file\n</code></pre> <p>Get the file object associated with the <code>TextObserver</code>.</p> <p>Returns:</p> <ul> <li> <code>IO</code>           \u2013            <p>The file object associated with the <code>TextObserver</code>.</p> </li> </ul>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return a representation of the <code>TextObserver</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The representation of the <code>TextObserver</code>.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a representation of the `TextObserver`.\n\n    Returns\n    -------\n    str\n        The representation of the `TextObserver`.\n    \"\"\"\n    return f\"{self.__class__.__name__}({self.__str__()}, mode={self.mode}, encoding={self.encoding}, interval={self.interval})\"\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string representation of the <code>TextObserver</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The string representation of the <code>TextObserver</code>, including the file type and name.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the `TextObserver`.\n\n    Returns\n    -------\n    str\n        The string representation of the `TextObserver`, including the file type and name.\n    \"\"\"\n    if self._file in (sys.stdout, sys.stderr, sys.stdin):\n        return f\"Stream:{self._file.name}\"\n\n    if hasattr(self._file, \"name\"):\n        name = self._file.name\n\n        if (\n            not isinstance(name, int)\n            and isinstance(name, str)\n            and name not in (\"\", \".\")\n        ):\n            return f\"Path:{name}\"\n\n    if hasattr(self._file, \"__class__\"):\n        return f\"Class:{self._file.__class__.__name__}\"\n\n    return \"Class:&lt;Unknown&gt;\"\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.attach_simulation","title":"attach_simulation","text":"<pre><code>attach_simulation(file_manager)\n</code></pre> <p>Attach the simulation to the <code>Observer</code> via a <code>FileManager</code>.</p> <p>Parameters:</p> <ul> <li> <code>file_manager</code>               (<code>FileManager</code>)           \u2013            <p>The <code>FileManager</code> instance to attach to the observer.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def attach_simulation(self, file_manager: FileManager) -&gt; None:\n    \"\"\"\n    Attach the simulation to the `Observer` via a `FileManager`.\n\n    Parameters\n    ----------\n    file_manager : FileManager\n        The `FileManager` instance to attach to the observer.\n    \"\"\"\n    file_manager.register(self.close)\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the file if it is not a standard stream.</p> Source code in <code>quansino/io/core.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the file if it is not a standard stream.\"\"\"\n    if not hasattr(self, \"_file\"):\n        return\n\n    if self._file not in (sys.stdout, sys.stderr, sys.stdin):\n        with suppress(OSError, AttributeError, ValueError):\n            self._file.close()\n\n            atexit.unregister(self.close)\n</code></pre>"},{"location":"reference/quansino/io/core.html#quansino.io.core.TextObserver.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>TextObserver</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>TextObserver</code>.</p> </li> </ul> Source code in <code>quansino/io/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `TextObserver` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `TextObserver`.\n    \"\"\"\n    dictionary = super().to_dict()\n    dictionary.setdefault(\"kwargs\", {})\n\n    dictionary[\"kwargs\"][\"mode\"] = self.mode\n    dictionary[\"kwargs\"][\"encoding\"] = self.encoding\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/io/file.html","title":"file","text":""},{"location":"reference/quansino/io/file.html#quansino.io.file.FileManager","title":"FileManager","text":"<pre><code>FileManager()\n</code></pre> <p>Class to automatically manage file resources. This class uses an <code>ExitStack</code> object to register file resources that need to be closed when the program exits or when the context manager is exited. It can be used to ensure that files are properly closed, preventing resource leaks.</p> <p>Attributes:</p> <ul> <li> <code>exitstack</code>               (<code>ExitStack</code>)           \u2013            <p>The exit stack used for managing file resources.</p> </li> </ul> Example <pre><code>from quansino.io.file import FileManager\n\nwith FileManager() as fm:\n    file = open(\"example.txt\", \"w\")\n    fm.register(file.close)  # Register the file close method\n    file.write(\"Hello, World!\")\n# The file will be automatically closed when exiting the context manager\n</code></pre> Notes <p>This class is mainly used in the <code>Driver</code> class to manage file resources automatically. Users are free to use it directly for managing their own file resources as well.</p> Source code in <code>quansino/io/file.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the FileManager with an ExitStack for resource management.\"\"\"\n    self.exitstack: Final[ExitStack] = ExitStack()\n\n    atexit.register(self.close)\n</code></pre>"},{"location":"reference/quansino/io/file.html#quansino.io.file.FileManager.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Enter the context manager and return self.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The instance of the <code>FileManager</code>.</p> </li> </ul> Source code in <code>quansino/io/file.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"\n    Enter the context manager and return self.\n\n    Returns\n    -------\n    Self\n        The instance of the `FileManager`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/quansino/io/file.html#quansino.io.file.FileManager.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args, **kwargs)\n</code></pre> <p>Exit the context manager and close all files.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments passed to the exit method.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments passed to the exit method.</p> </li> </ul> Source code in <code>quansino/io/file.py</code> <pre><code>def __exit__(self, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Exit the context manager and close all files.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments passed to the exit method.\n    **kwargs : Any\n        Keyword arguments passed to the exit method.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"reference/quansino/io/file.html#quansino.io.file.FileManager.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close all registered resources</p> Source code in <code>quansino/io/file.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close all registered resources\"\"\"\n    with suppress(OSError, AttributeError, ValueError):\n        self.exitstack.close()\n        atexit.unregister(self.close)\n</code></pre>"},{"location":"reference/quansino/io/file.html#quansino.io.file.FileManager.register","title":"register","text":"<pre><code>register(resource)\n</code></pre> <p>Register a resource for automatic cleanup. This method registers a callable resource (like a file close method) to be called when the context manager exits or when the program terminates. It returns the result of the callback, which is typically <code>None</code> for close methods.</p> <p>Parameters:</p> <ul> <li> <code>resource</code>               (<code>Callable</code>)           \u2013            <p>The resource to register for cleanup.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the callback, typically <code>None</code> for close methods.</p> </li> </ul> Source code in <code>quansino/io/file.py</code> <pre><code>def register(self, resource: Callable) -&gt; Any:\n    \"\"\"\n    Register a resource for automatic cleanup. This method registers a callable resource (like a file close method) to be called when the context manager exits or when the program terminates. It returns the result of the callback, which is typically `None` for close methods.\n\n    Parameters\n    ----------\n    resource : Callable\n        The resource to register for cleanup.\n\n    Returns\n    -------\n    Any\n        The result of the callback, typically `None` for close methods.\n    \"\"\"\n    return self.exitstack.callback(resource)\n</code></pre>"},{"location":"reference/quansino/io/logger.html","title":"logger","text":"<p>General purpose logging module for atomistic simulations.</p>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger","title":"Logger","text":"<pre><code>Logger(logfile, interval, mode='a', **observer_kwargs)\n</code></pre> <p>               Bases: <code>TextObserver</code></p> <p>A general purpose logger for atomistic simulations, if created manually, the <code>add_field</code> method must be called to configure fields to log. The logger will write the current values of all configured fields to the log file at specified intervals. Callable required for <code>add_field</code> can be easily created by calling functions to obtain the desired value. The logger can also be configured using convenience methods, such as <code>add_mc_fields</code> and <code>add_opt_fields</code>. This will be done automatically by Monte Carlo classes if the <code>logfile</code> parameter is set.</p> Example <pre><code>logger.add_field(\"Epot[eV]\", atoms.get_potential_energy)\nlogger.add_field(\n    \"Class\",\n    lambda: simulation.__class__.__name__,\n    \"{:&gt;12s}\",\n)\nlogger.add_mc_fields(my_mc_simulation)\nlogger.add_opt_fields(my_optimization_simulation)\nlogger.add_stress_fields(atoms, mask=[True, True, True, False, False, False])\n</code></pre> <p>Parameters:</p> <ul> <li> <code>logfile</code>               (<code>IO | str | Path</code>)           \u2013            <p>File path or open file object for logging.</p> </li> <li> <code>interval</code>               (<code>int</code>)           \u2013            <p>Interval at which to log the fields, e.g., every <code>interval</code> steps.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>File opening mode if logfile is a filename or path, by default \"a\".</p> </li> <li> <code>**observer_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the parent <code>TextObserver</code> class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>fields</code>               (<code>dict[str | tuple[str, ...], dict[str, Any]]</code>)           \u2013            <p>Dictionary of fields to log, fields can be added with the <code>add_field</code> method, or using convenience methods such as <code>add_mc_fields</code> and <code>add_opt_fields</code>.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def __init__(\n    self,\n    logfile: IO | str | Path,\n    interval: int,\n    mode: str = \"a\",\n    **observer_kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the simulation `Logger` object.\"\"\"\n    super().__init__(file=logfile, interval=interval, mode=mode, **observer_kwargs)\n\n    self.fields: dict[str | tuple[str, ...], dict[str, Any]] = {}\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Log the current state of the simulation. Writes a new line to the log file containing the current values of all configured fields.</p> Source code in <code>quansino/io/logger.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"\n    Log the current state of the simulation. Writes a new line to the log file containing the current values of all configured fields.\n    \"\"\"\n    parts = []\n\n    for key in self.fields:\n        value = self.fields[key][\"function\"]()\n\n        if self.fields[key][\"is_array\"]:\n            parts.append(self.fields[key][\"str_format\"].format(*value))\n        else:\n            parts.append(self.fields[key][\"str_format\"].format(value))\n\n    self._file.write(\" \".join(parts) + \"\\n\")\n    self._file.flush()\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.add_field","title":"add_field","text":"<pre><code>add_field(name, function, str_format='{:10.3f}', header_format=None, is_array=False)\n</code></pre> <p>Add one field to the logger, which track a value that changes during the simulation.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | list[str] | tuple[str, ...]</code>)           \u2013            <p>Name of the field to add, can be a single string or a list/tuple of strings for array fields.</p> </li> <li> <code>function</code>               (<code>Callable[[], Any]</code>)           \u2013            <p>Callable object returning the value of the field.</p> </li> <li> <code>str_format</code>               (<code>str</code>, default:                   <code>'{:10.3f}'</code> )           \u2013            <p>Format string for field value, by default \"{:10.3f}\".</p> </li> <li> <code>header_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Format string for field name in the header line, if <code>None</code>, it will be automatically generated based on the <code>str_format</code> parameter.</p> </li> <li> <code>is_array</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the field's function returns a list of values, by default False. If True, <code>name</code> can either be a single string or a list/tuple of strings for each component of the array, and <code>str_format</code> should contain the same number of placeholders as the length of the list.</p> </li> </ul> Example <pre><code>logger.add_field(\"Epot[eV]\", atoms.get_potential_energy)\nlogger.add_field(\n    \"Class\",\n    lambda: simulation.__class__.__name__,\n    \"{:&gt;12s}\",\n)\n</code></pre> Notes <p>The callable can return a list of values to log 1D-arrays or vectors. In this case, <code>str_format</code> should be a format string with the same number of placeholders as the length of the list. The <code>is_array</code> parameter should be set to <code>True</code>, see <code>add_stress_fields</code> for an example.</p> Source code in <code>quansino/io/logger.py</code> <pre><code>def add_field(\n    self,\n    name: str | list[str] | tuple[str, ...],\n    function: Callable[[], Any],\n    str_format: str = \"{:10.3f}\",\n    header_format: str | None = None,\n    is_array: bool = False,\n) -&gt; None:\n    \"\"\"\n    Add one field to the logger, which track a value that changes during the simulation.\n\n    Parameters\n    ----------\n    name : str | list[str] | tuple[str, ...]\n        Name of the field to add, can be a single string or a list/tuple of strings for array fields.\n    function : Callable[[], Any]\n        Callable object returning the value of the field.\n    str_format : str, optional\n        Format string for field value, by default \"{:10.3f}\".\n    header_format : str | None, optional\n        Format string for field name in the header line, if `None`, it will be automatically generated based on the `str_format` parameter.\n    is_array : bool, optional\n        Whether the field's function returns a list of values, by default False. If True, `name` can either be a single string or a list/tuple of strings for each component of the array, and `str_format` should contain the same number of placeholders as the length of the list.\n\n    Example\n    -------\n    ``` python\n    logger.add_field(\"Epot[eV]\", atoms.get_potential_energy)\n    logger.add_field(\n        \"Class\",\n        lambda: simulation.__class__.__name__,\n        \"{:&gt;12s}\",\n    )\n    ```\n\n    Notes\n    -----\n    The callable can return a list of values to log 1D-arrays or vectors. In this case, `str_format` should be a format string with the same number of placeholders as the length of the list. The `is_array` parameter should be set to `True`, see [`add_stress_fields`][quansino.io.logger.Logger.add_stress_fields] for an example.\n    \"\"\"\n    if isinstance(name, list):\n        name = tuple(name)\n\n    if header_format is None:\n        header_format = get_auto_header_format(str_format)\n\n    self.fields[name] = {\n        \"function\": function,\n        \"str_format\": str_format,\n        \"header_format\": header_format,\n        \"is_array\": is_array,\n    }\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.add_mc_fields","title":"add_mc_fields","text":"<pre><code>add_mc_fields(simulation)\n</code></pre> <p>Convenience function to add commonly used fields for <code>MonteCarlo</code> simulations, add the following fields to the logger:</p> <ul> <li>Class: The name of the simulation class.</li> <li>Step: The current simulation step.</li> <li>Epot[eV]: The current potential energy.</li> </ul> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>MonteCarlo</code>)           \u2013            <p>The <code>MonteCarlo</code> simulation object to track.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def add_mc_fields(self, simulation: Driver) -&gt; None:\n    \"\"\"\n    Convenience function to add commonly used fields for [`MonteCarlo`][quansino.mc.core.MonteCarlo] simulations, add the following fields to the logger:\n\n    - Class: The name of the simulation class.\n    - Step: The current simulation step.\n    - Epot[eV]: The current potential energy.\n\n    Parameters\n    ----------\n    simulation : MonteCarlo\n        The [`MonteCarlo`][quansino.mc.core.MonteCarlo] simulation object to track.\n    \"\"\"\n    names = [\"Class\", \"Step\", \"Epot[eV]\"]\n    functions = [\n        lambda: simulation.__class__.__name__,\n        lambda: simulation.step_count,\n        simulation.atoms.get_potential_energy,\n    ]\n    str_formats = [\"{:&lt;24s}\", \"{:&gt;12d}\", \"{:&gt;12.4f}\"]\n\n    for name, function, str_format in zip(\n        names, functions, str_formats, strict=False\n    ):\n        self.add_field(name, function, str_format)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.add_md_fields","title":"add_md_fields","text":"<pre><code>add_md_fields(simulation)\n</code></pre> <p>Convenience function to add commonly used fields for <code>MolecularDynamics</code> simulations, add the following fields to the logger:</p> <ul> <li>Time[ps]: The current simulation time in picoseconds.</li> <li>Epot[eV]: The current potential energy.</li> <li>Ekin[eV]: The current kinetic energy.</li> <li>T[K]: The current temperature.</li> </ul> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>MolecularDynamics</code>)           \u2013            <p>The ASE <code>MolecularDynamics</code> object to track.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def add_md_fields(self, simulation: MolecularDynamics) -&gt; None:\n    \"\"\"\n    Convenience function to add commonly used fields for `MolecularDynamics` simulations, add the following fields to the logger:\n\n    - Time[ps]: The current simulation time in picoseconds.\n    - Epot[eV]: The current potential energy.\n    - Ekin[eV]: The current kinetic energy.\n    - T[K]: The current temperature.\n\n    Parameters\n    ----------\n    simulation : MolecularDynamics\n        The ASE `MolecularDynamics` object to track.\n    \"\"\"\n    names = [\"Time[ps]\", \"Epot[eV]\", \"Ekin[eV]\", \"T[K]\"]\n    functions = [\n        lambda: simulation.get_time() / (1000 * units.fs),\n        simulation.atoms.get_potential_energy,\n        simulation.atoms.get_kinetic_energy,\n        simulation.atoms.get_temperature,\n    ]\n    str_formats = [\"{:&lt;12.4f}\"] + [\"{:&gt;12.4f}\"] * 2 + [\"{:&gt;10.2f}\"]\n\n    for name, function, str_format in zip(\n        names, functions, str_formats, strict=False\n    ):\n        self.add_field(name, function, str_format)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.add_opt_fields","title":"add_opt_fields","text":"<pre><code>add_opt_fields(simulation)\n</code></pre> <p>Convenience function to add commonly used fields for <code>Optimizer</code> simulations, add the following fields to the logger:</p> <ul> <li>Optimizer: The name of the optimizer class.</li> <li>Step: The current optimization step.</li> <li>Time: The current time in HH:MM:SS format.</li> <li>Epot[eV]: The current potential energy.</li> <li>Fmax[eV/A]: The maximum force component.</li> </ul> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Optimizer</code>)           \u2013            <p>The ASE <code>Optimizer</code> object to track.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def add_opt_fields(self, simulation: Optimizer) -&gt; None:\n    \"\"\"\n    Convenience function to add commonly used fields for `Optimizer` simulations, add the following fields to the logger:\n\n    - Optimizer: The name of the optimizer class.\n    - Step: The current optimization step.\n    - Time: The current time in HH:MM:SS format.\n    - Epot[eV]: The current potential energy.\n    - Fmax[eV/A]: The maximum force component.\n\n    Parameters\n    ----------\n    simulation : Optimizer\n        The ASE `Optimizer` object to track.\n    \"\"\"\n    names = [\"Class\", \"Step\", \"Time\", \"Epot[eV]\", \"Fmax[eV/A]\"]\n    functions = [\n        lambda: simulation.__class__.__name__,\n        lambda: simulation.nsteps,\n        lambda: \"{:02d}:{:02d}:{:02d}\".format(*time.localtime()[3:6]),\n        simulation.atoms.get_potential_energy,\n        lambda: np.linalg.norm(simulation.atoms.get_forces(), axis=1).max(),\n    ]\n    str_formats = [\"{:&lt;24s}\"] + [\"{:&gt;4d}\"] + [\"{:&gt;12s}\"] + [\"{:&gt;12.4f}\"] * 2\n\n    for name, function, str_format in zip(\n        names, functions, str_formats, strict=False\n    ):\n        self.add_field(name, function, str_format)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.add_stress_fields","title":"add_stress_fields","text":"<pre><code>add_stress_fields(atoms, include_ideal_gas=True, mask=None)\n</code></pre> <p>Add stress fields to the logger for all components of the stress tensor. These can be masked using the <code>mask</code> parameter.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The ASE atoms object to track.</p> </li> <li> <code>include_ideal_gas</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include the ideal gas contribution to the stress, by default True.</p> </li> <li> <code>mask</code>               (<code>list[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of booleans to mask the stress components to log, by default None. If None, all components will be logged. The order of components is: xx, yy, zz, yz, xz, xy.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def add_stress_fields(\n    self,\n    atoms: Atoms,\n    include_ideal_gas: bool = True,\n    mask: list[bool] | None = None,\n) -&gt; None:\n    \"\"\"\n    Add stress fields to the logger for all components of the stress tensor. These can be masked using the `mask` parameter.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The ASE atoms object to track.\n    include_ideal_gas : bool, optional\n        Whether to include the ideal gas contribution to the stress, by default True.\n    mask : list[bool] | None, optional\n        A list of booleans to mask the stress components to log, by default None. If None, all components will be logged. The order of components is: xx, yy, zz, yz, xz, xy.\n    \"\"\"\n    if mask is None:\n        mask = [True] * 6\n\n    def log_stress() -&gt; Stress:\n        \"\"\"\n        Get the stress tensor from the atoms object and convert it to GPa.\n\n        Returns\n        -------\n        Stress\n            The stress tensor in GPa, masked according to the `mask` parameter.\n        \"\"\"\n        stress = atoms.get_stress(include_ideal_gas=include_ideal_gas)\n        stress = tuple(stress / units.GPa)\n\n        return np.array([s for n, s in enumerate(stress) if mask[n]])\n\n    components = [\"xx\", \"yy\", \"zz\", \"yz\", \"xz\", \"xy\"]\n    names = [\n        f\"Stress[{component}][GPa]\"\n        for n, component in enumerate(components)\n        if mask[n]\n    ]\n    formats = \"{:&gt;18.3f}\" * sum(mask)\n\n    self.add_field(names, log_stress, formats, is_array=True)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.create_header","title":"create_header","text":"<pre><code>create_header()\n</code></pre> <p>Create the header format string based on configured fields.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted header string.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def create_header(self) -&gt; str:\n    \"\"\"\n    Create the header format string based on configured fields.\n\n    Returns\n    -------\n    str\n        Formatted header string.\n    \"\"\"\n    to_write = []\n\n    for name in self.fields:\n        header_format = self.fields[name][\"header_format\"]\n        if self.fields[name][\"is_array\"] and isinstance(name, tuple):\n            to_write.append(header_format.format(*name))\n        else:\n            to_write.append(header_format.format(name))\n\n    return \" \".join(to_write)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.remove_fields","title":"remove_fields","text":"<pre><code>remove_fields(pattern)\n</code></pre> <p>Remove fields whose names contain the given pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>Pattern to match in field names. For compound fields (tuple of names), matches if any component contains the pattern.</p> </li> </ul> Source code in <code>quansino/io/logger.py</code> <pre><code>def remove_fields(self, pattern: str) -&gt; None:\n    \"\"\"\n    Remove fields whose names contain the given pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        Pattern to match in field names. For compound fields (tuple of names), matches if any component contains the pattern.\n    \"\"\"\n    for field_name in list(self.fields.keys()):\n        if isinstance(field_name, tuple):\n            if any(pattern in name for name in field_name):\n                self.fields.pop(field_name)\n        else:\n            if pattern in field_name:\n                self.fields.pop(field_name)\n</code></pre>"},{"location":"reference/quansino/io/logger.html#quansino.io.logger.Logger.write_header","title":"write_header","text":"<pre><code>write_header()\n</code></pre> <p>Write the header line to the log file.</p> Source code in <code>quansino/io/logger.py</code> <pre><code>def write_header(self) -&gt; None:\n    \"\"\"Write the header line to the log file.\"\"\"\n    self._file.write(f\"{self.create_header()}\\n\")\n</code></pre>"},{"location":"reference/quansino/io/restart.html","title":"restart","text":""},{"location":"reference/quansino/io/restart.html#quansino.io.restart.RestartObserver","title":"RestartObserver","text":"<pre><code>RestartObserver(simulation, file, interval=1, mode='a', write_kwargs=None, **observer_kwargs)\n</code></pre> <p>               Bases: <code>TextObserver</code></p> <p>Observer to write restart data for atomistic simulations. This observer writes the state of the simulation to a file in JSON format at specified intervals, allowing for the simulation to be restarted later.</p> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Driver</code>)           \u2013            <p>The simulation driver to observe and write restart data for.</p> </li> <li> <code>file</code>               (<code>IO | Path | str</code>)           \u2013            <p>The file to write restart data to.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The interval at which to write restart data, by default 1.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>The mode in which to open the file, by default \"a\".</p> </li> <li> <code>write_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the JSON writer function, by default None.</p> </li> <li> <code>**observer_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the parent TextObserver.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>accept_stream</code>               (<code>bool</code>)           \u2013            <p>Whether to accept a stream of data. This is set to False by default, as this observer does not handle streaming data.</p> </li> <li> <code>write_kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Additional keyword arguments to pass to the JSON writer function.</p> </li> </ul> Source code in <code>quansino/io/restart.py</code> <pre><code>def __init__(\n    self,\n    simulation: Driver,\n    file: IO | Path | str,\n    interval: int = 1,\n    mode: str = \"a\",\n    write_kwargs: dict[str, Any] | None = None,\n    **observer_kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the `RestartObserver` with a file, interval, and other parameters.\n    \"\"\"\n    super().__init__(file=file, interval=interval, mode=mode, **observer_kwargs)\n\n    self.simulation: Driver = proxy(simulation)\n    self.write_kwargs = write_kwargs or {}\n</code></pre>"},{"location":"reference/quansino/io/restart.html#quansino.io.restart.RestartObserver.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Call the function to write the restart data to the file.</p> Source code in <code>quansino/io/restart.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Call the function to write the restart data to the file.\"\"\"\n    self._file.seek(0)\n    self._file.truncate()\n\n    write_json(self._file, obj=self.simulation, **self.write_kwargs)\n    self._file.flush()\n</code></pre>"},{"location":"reference/quansino/io/trajectory.html","title":"trajectory","text":""},{"location":"reference/quansino/io/trajectory.html#quansino.io.trajectory.TrajectoryObserver","title":"TrajectoryObserver","text":"<pre><code>TrajectoryObserver(atoms, file, interval=1, mode='a', write_kwargs=None, **observer_kwargs)\n</code></pre> <p>               Bases: <code>TextObserver</code></p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object to write to the trajectory file.</p> </li> <li> <code>file</code>               (<code>IO | str | Path</code>)           \u2013            <p>The file or path to the trajectory file.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The interval at which to write the trajectory, by default 1.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>The mode in which to open the file (e.g., 'a' for append), by default \"a\".</p> </li> <li> <code>write_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the writing function, by default None.</p> </li> <li> <code>**observer_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the observer class.</p> </li> </ul> Source code in <code>quansino/io/trajectory.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    file: IO | Path | str,\n    interval: int = 1,\n    mode: str = \"a\",\n    write_kwargs: dict[str, Any] | None = None,\n    **observer_kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the `TrajectoryObserver` with mode, and other parameters. In `quansino`, trajectory files are written in the XYZ format using ASE's `write_xyz` function.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The ASE Atoms object to write to the trajectory file.\n    file : IO | str | Path\n        The file or path to the trajectory file.\n    interval : int, optional\n        The interval at which to write the trajectory, by default 1.\n    mode : str, optional\n        The mode in which to open the file (e.g., 'a' for append), by default \"a\".\n    write_kwargs : dict[str, Any] | None, optional\n        Additional keyword arguments to pass to the writing function, by default None.\n    **observer_kwargs : Any\n        Additional keyword arguments for the observer class.\n    \"\"\"\n    super().__init__(file=file, interval=interval, mode=mode, **observer_kwargs)\n\n    self.atoms = proxy(atoms)\n    self.write_kwargs = write_kwargs or {}\n</code></pre>"},{"location":"reference/quansino/io/trajectory.html#quansino.io.trajectory.TrajectoryObserver.__call__","title":"__call__","text":"<pre><code>__call__()\n</code></pre> <p>Call the function to write the trajectory to the file.</p> Source code in <code>quansino/io/trajectory.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Call the function to write the trajectory to the file.\"\"\"\n    write_xyz(self._file, images=self.atoms, **self.write_kwargs)\n    self._file.flush()\n</code></pre>"},{"location":"reference/quansino/mc/canonical.html","title":"canonical","text":"<p>Module to perform canonical (NVT) Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.Canonical","title":"Canonical","text":"<pre><code>Canonical(atoms, temperature=298.15, max_cycles=None, default_displacement_move=None, **mc_kwargs)\n</code></pre> <p>               Bases: <code>MonteCarlo[MoveType, CriteriaType]</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Canonical Monte Carlo simulation object for performing NVT simulations. This class is a subclass of the <code>MonteCarlo</code> class and provides additional functionality specific to canonical simulations. By default, it uses the <code>DisplacementContext</code> context.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on, will be acted upon in place.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>The temperature of the simulation in Kelvin, by default 298.15 K.</p> </li> <li> <code>max_cycles</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of Monte Carlo cycles to perform, by default equal to the number of atoms.</p> </li> <li> <code>default_displacement_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default displacement move to perform in each cycle, by default None.</p> </li> <li> <code>**mc_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>MonteCarlo</code> and <code>Driver</code> class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>default_context</code>               (<code>ClassVar[type[DisplacementContext]]</code>)           \u2013            <p>The default context used for the simulation, set to <code>DisplacementContext</code>.</p> </li> <li> <code>default_criteria</code>               (<code>ClassVar[dict[type[Move], type[Criteria]]]</code>)           \u2013            <p>The default criteria used for the simulation, set to <code>CanonicalCriteria</code>.</p> </li> </ul> Source code in <code>quansino/mc/canonical.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    temperature: float = 298.15,\n    max_cycles: int | None = None,\n    default_displacement_move: MoveType | None = None,\n    **mc_kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the `Canonical` object.\"\"\"\n    if max_cycles is None:\n        max_cycles = len(atoms)\n\n    super().__init__(atoms, max_cycles=max_cycles, **mc_kwargs)\n\n    self.temperature = temperature\n\n    if default_displacement_move:\n        self.add_move(default_displacement_move, name=\"default_displacement_move\")\n\n    if self.default_logger:\n        self.default_logger.add_field(\"AcptRate\", lambda: self.acceptance_rate)\n\n    if isinstance(self.context, DisplacementContext):\n        self.context = cast(\"DisplacementContext\", self.context)\n    else:\n        warn(\n            \"The context is not a `DisplacementContext`. This may lead to unexpected behavior.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.Canonical.temperature","title":"temperature  <code>property</code> <code>writable</code>","text":"<pre><code>temperature\n</code></pre> <p>The temperature of the simulation in Kelvin, retrieved from the context.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The temperature in Kelvin.</p> </li> </ul>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.Canonical.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert to the previously saved state of the atoms, attempting to restore the positions from the last saved state.</p> Source code in <code>quansino/mc/canonical.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert to the previously saved state of the atoms, attempting to restore the positions from the last saved state.\n    \"\"\"\n    super().revert_state()\n\n    try:\n        self.atoms.calc.atoms.positions = self.atoms.positions.copy()  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\n            \"The calculator does not support restoring positions. Please check that your calculator is fully compatible with quansino.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.Canonical.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>Canonical</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>Canonical</code> object.</p> </li> </ul> Source code in <code>quansino/mc/canonical.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `Canonical` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `Canonical` object.\n    \"\"\"\n    dictionary = super().to_dict()\n    dictionary[\"kwargs\"][\"temperature\"] = self.temperature\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.Canonical.validate_simulation","title":"validate_simulation","text":"<pre><code>validate_simulation()\n</code></pre> <p>Validate the simulation by checking if the last positions and last energy are set.</p> Source code in <code>quansino/mc/canonical.py</code> <pre><code>def validate_simulation(self) -&gt; None:\n    \"\"\"\n    Validate the simulation by checking if the last positions and last energy are set.\n    \"\"\"\n    self.context.last_positions = self.atoms.get_positions()\n\n    if np.isnan(self.context.last_potential_energy):\n        self.context.last_potential_energy = self.atoms.get_potential_energy()\n\n    super().validate_simulation()\n</code></pre>"},{"location":"reference/quansino/mc/canonical.html#quansino.mc.canonical.HamiltonianCanonical","title":"HamiltonianCanonical","text":"<pre><code>HamiltonianCanonical(atoms, **canonical_kwargs)\n</code></pre> <p>               Bases: <code>Canonical[MoveType, CriteriaType]</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Hamiltonian Canonical Monte Carlo simulation object for performing NVT simulations with Hamiltonian moves. This class is a subclass of the <code>Canonical</code> class and provides additional functionality specific to Hamiltonian canonical simulations. By default, it uses the [<code>HamiltonianDisplacementContext</code>][quansino.mc.contexts.HamiltonianDisplacementContext] context.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on, will be acted upon in place.</p> </li> <li> <code>**canonical_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>Canonical</code> class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>default_context</code>               (<code>ClassVar[type[HamiltonianDisplacementContext]]</code>)           \u2013            <p>The default context used for the simulation, set to [<code>HamiltonianDisplacementContext</code>][quansino.mc.contexts.HamiltonianDisplacementContext].</p> </li> </ul> Source code in <code>quansino/mc/canonical.py</code> <pre><code>def __init__(self, atoms: Atoms, **canonical_kwargs: Any):\n    \"\"\"Initialize the `HamiltonianCanonical` object.\"\"\"\n    super().__init__(atoms, **canonical_kwargs)\n\n    if self.default_logger is not None:\n        self.default_logger.add_field(\"Ekin[eV]\", self.atoms.get_kinetic_energy)\n\n    if isinstance(self.context, HamiltonianDisplacementContext):\n        self.context = cast(\"HamiltonianDisplacementContext\", self.context)\n    else:\n        warn(\n            \"The context is not a `HamiltonianDisplacementContext`. This may lead to unexpected behavior.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html","title":"contexts","text":"<p>Module for Monte Carlo contexts.</p>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.Context","title":"Context","text":"<pre><code>Context(atoms, rng)\n</code></pre> <p>Abstract base class for Monte Carlo contexts. Contexts define the interface between the simulation object, the moves and their criteria. They aim to provide the necessary information for the move to perform its operation, without having to pass whole simulation objects around. Specific context might be required for different types of moves, for example, <code>DisplacementContext</code> for displacement moves, <code>DeformationContext</code> for cell deformation move, and <code>ExchangeContext</code> for exchange moves.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>The random number generator to use.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object which the context operates on.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>The random number generator in use.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def __init__(self, atoms: Atoms, rng: Generator) -&gt; None:\n    \"\"\"Initialize the `Context` object.\"\"\"\n    self.atoms: Atoms = atoms\n    self.rng: Generator = rng\n\n    self.last_results: dict[str, Any] = {}\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.Context.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the context to the last saved state. This method can be overridden by subclasses to revert specific attributes.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the context to the last saved state. This method can be overridden by subclasses to revert specific attributes.\n    \"\"\"\n    try:\n        self.atoms.calc.results = self.last_results  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\n            \"Atoms object does not have calculator attached, or does not support the `results` attribute\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.Context.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context. This method can be overridden by subclasses to save specific attributes.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the context. This method can be overridden by subclasses to save specific attributes.\n    \"\"\"\n    try:\n        self.last_results = self.atoms.calc.results  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\n            \"Atoms object does not have calculator attached, or does not support the `results` attribute\",\n            UserWarning,\n            2,\n        )\n        self.last_results = {}\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.Context.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the Context object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the context.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the Context object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the context.\n    \"\"\"\n    return {\"last_results\": self.last_results}\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DeformationContext","title":"DeformationContext","text":"<pre><code>DeformationContext(atoms, rng)\n</code></pre> <p>               Bases: <code>DisplacementContext</code></p> <p>Context for strain moves i.e. moves that change the cell of the simulation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>The random number generator to use.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>pressure</code>               (<code>float</code>)           \u2013            <p>The pressure of the system.</p> </li> <li> <code>last_cell</code>               (<code>Cell</code>)           \u2013            <p>The cell of the atoms in the last saved state.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def __init__(self, atoms: Atoms, rng: Generator) -&gt; None:\n    \"\"\"Initialize the `DeformationContext` object.\"\"\"\n    super().__init__(atoms, rng)\n\n    self.pressure: float = 0.0\n    self.external_stress: Stress = np.zeros((3, 3))\n    self.last_cell: Cell = atoms.get_cell()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DeformationContext.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the context to the last saved state, restoring the last cell.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the context to the last saved state, restoring the last cell.\n    \"\"\"\n    super().revert_state()\n    self.atoms.set_cell(self.last_cell, scale_atoms=False)\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DeformationContext.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context, including the last cell.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the context, including the last cell.\n    \"\"\"\n    super().save_state()\n    self.last_cell = self.atoms.get_cell()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DeformationContext.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>DeformationContext</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>DeformationContext</code> object.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `DeformationContext` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `DeformationContext` object.\n    \"\"\"\n    return {\n        **super().to_dict(),\n        \"pressure\": self.pressure,\n        \"last_cell\": self.last_cell,\n    }\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DisplacementContext","title":"DisplacementContext","text":"<pre><code>DisplacementContext(atoms, rng)\n</code></pre> <p>               Bases: <code>Context</code></p> <p>Context for displacement moves i.e. moves that displace atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>The random number generator to use.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>temperature</code>               (<code>float</code>)           \u2013            <p>The temperature of the simulation in Kelvin.</p> </li> <li> <code>last_positions</code>               (<code>Positions</code>)           \u2013            <p>The positions of the atoms in the last saved state.</p> </li> <li> <code>last_energy</code>               (<code>float</code>)           \u2013            <p>The energy value from the last saved state.</p> </li> <li> <code>_moving_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>Integer indices of atoms that are being displaced.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def __init__(self, atoms: Atoms, rng: Generator) -&gt; None:\n    \"\"\"Initialize the `DisplacementContext` object.\"\"\"\n    super().__init__(atoms, rng)\n\n    self.temperature: float = 0.0\n\n    self.last_positions: Positions = atoms.get_positions()\n    self.last_potential_energy: float = np.nan\n\n    self.reset()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DisplacementContext.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the context by setting <code>moving_indices</code> to an empty list.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the context by setting `moving_indices` to an empty list.\"\"\"\n    self._moving_indices: IntegerArray = []\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DisplacementContext.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the context to the last saved state, restoring the last positions.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"Revert the context to the last saved state, restoring the last positions.\"\"\"\n    self.atoms.positions = self.last_positions.copy()\n\n    super().revert_state()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DisplacementContext.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context, including the last positions and energy.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"Save the current state of the context, including the last positions and energy.\"\"\"\n    self.last_positions = self.atoms.get_positions()\n    self.last_potential_energy = self.atoms.get_potential_energy()\n\n    super().save_state()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.DisplacementContext.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>DisplacementContext</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>DisplacementContext</code> object.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `DisplacementContext` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `DisplacementContext` object.\n    \"\"\"\n    return {\n        **super().to_dict(),\n        \"temperature\": self.temperature,\n        \"last_positions\": self.last_positions,\n        \"last_potential_energy\": self.last_potential_energy,\n    }\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.ExchangeContext","title":"ExchangeContext","text":"<pre><code>ExchangeContext(atoms, rng)\n</code></pre> <p>               Bases: <code>DisplacementContext</code></p> <p>Context for exchange moves i.e. moves that exchange atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>The random number generator to use.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>_added_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>Integer indices of atoms that were added in the last move.</p> </li> <li> <code>_added_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms that were added in the last move.</p> </li> <li> <code>_deleted_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>Integer indices of atoms that were deleted in the last move.</p> </li> <li> <code>_deleted_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms that were deleted in the last move.</p> </li> <li> <code>accessible_volume</code>               (<code>float</code>)           \u2013            <p>The accessible volume of the system.</p> </li> <li> <code>chemical_potential</code>               (<code>float</code>)           \u2013            <p>The chemical potential of the system.</p> </li> <li> <code>exchange_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms that can be exchanged in the simulation.</p> </li> <li> <code>number_of_exchange_particles</code>               (<code>int</code>)           \u2013            <p>The number of particles that can be exchanged.</p> </li> <li> <code>particle_delta</code>               (<code>int</code>)           \u2013            <p>The change in the number of particles in the last move, positive for addition and negative for deletion.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def __init__(self, atoms: Atoms, rng: Generator) -&gt; None:\n    \"\"\"Initialize the `ExchangeContext` object.\"\"\"\n    super().__init__(atoms, rng)\n\n    self.chemical_potential = np.nan\n\n    self.exchange_atoms: Atoms = Atoms()\n    self.number_of_exchange_particles = 0\n\n    self.accessible_volume = self.atoms.cell.volume\n\n    self.reset()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.ExchangeContext.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the context by setting all attributes to their default values.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the context by setting all attributes to their default values.\n    \"\"\"\n    self._added_indices: IntegerArray = []\n    self._added_atoms: Atoms = Atoms()\n    self._deleted_indices: IntegerArray = []\n    self._deleted_atoms: Atoms = Atoms()\n\n    self.particle_delta = 0\n\n    super().reset()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.ExchangeContext.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the context to the last saved state.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the context to the last saved state.\n    \"\"\"\n    if len(self._added_indices) != 0:\n        del self.atoms[self._added_indices]\n    if len(self._deleted_indices) != 0:\n        if len(self._deleted_atoms) == 0:\n            raise ValueError(\"Last deleted atoms was not saved.\")\n\n        reinsert_atoms(self.atoms, self._deleted_atoms, self._deleted_indices)\n\n    super().revert_state()\n    self.reset()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.ExchangeContext.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context, including the number of exchange particles.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the context, including the number of exchange particles.\n    \"\"\"\n    super().save_state()\n    self.number_of_exchange_particles += self.particle_delta\n    self.reset()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.ExchangeContext.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>ExchangeContext</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>ExchangeContext</code> object.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `ExchangeContext` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `ExchangeContext` object.\n    \"\"\"\n    return {\n        **super().to_dict(),\n        \"chemical_potential\": self.chemical_potential,\n        \"number_of_exchange_particles\": self.number_of_exchange_particles,\n        \"accessible_volume\": self.accessible_volume,\n        \"exchange_atoms\": self.exchange_atoms,\n    }\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.HamiltonianContext","title":"HamiltonianContext","text":"<pre><code>HamiltonianContext(atoms, rng)\n</code></pre> <p>               Bases: <code>Context</code></p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def __init__(self, atoms, rng):\n    super().__init__(atoms, rng)\n\n    self.last_momenta: Momenta = atoms.get_momenta()\n    self.last_kinetic_energy: float = np.nan\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.HamiltonianContext.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the context to the last saved state, restoring the last momenta and kinetic energy.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the context to the last saved state, restoring the last momenta and kinetic energy.\n    \"\"\"\n    self.atoms.set_array(\"momenta\", self.last_momenta.copy(), float, (3,))\n\n    super().revert_state()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.HamiltonianContext.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context, including the last momenta and kinetic energy.</p> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the context, including the last momenta and kinetic energy.\n    \"\"\"\n    self.last_momenta = self.atoms.get_momenta()\n    self.last_kinetic_energy = self.atoms.get_kinetic_energy()  # type: ignore[ase]\n\n    super().save_state()\n</code></pre>"},{"location":"reference/quansino/mc/contexts.html#quansino.mc.contexts.HamiltonianContext.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>HMCContext</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>HMCContext</code> object.</p> </li> </ul> Source code in <code>quansino/mc/contexts.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `HMCContext` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `HMCContext` object.\n    \"\"\"\n    return {\n        **super().to_dict(),\n        \"last_momenta\": self.last_momenta,\n        \"last_kinetic_energy\": self.last_kinetic_energy,\n    }\n</code></pre>"},{"location":"reference/quansino/mc/core.html","title":"core","text":"<p>Module to run and create Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo","title":"MonteCarlo","text":"<pre><code>MonteCarlo(atoms, max_cycles=1, seed=None, logfile=None, trajectory=None, restart_file=None, logging_interval=1, logging_mode='a')\n</code></pre> <p>               Bases: <code>Driver</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Base class providing an interface for all Monte Carlo classes. The <code>MonteCarlo</code> class is responsible for selecting moves to perform via the <code>yield_moves</code> method. This class is also responsible for managing the moves, their parameters (interval, probability, minimum count), and their acceptance criteria. Logging and trajectory writing are handled by the parent <code>Driver</code> class. When necessary, communication between the Monte Carlo simulation and the moves is facilitated by the context object. The Monte Carlo class and its subclasses should not directly modify the moves, but rather interact using the context object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to operate on.</p> </li> <li> <code>max_cycles</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of Monte Carlo cycles per step, by default 1.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Seed for the random number generator, by default None. If None, a random seed is generated.</p> </li> <li> <code>logfile</code>               (<code>Logger | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Logger observer to auto-attach, by default None.</p> </li> <li> <code>trajectory</code>               (<code>TrajectoryObserver | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Trajectory observer to auto-attach, by default None.</p> </li> <li> <code>restart_file</code>               (<code>RestartObserver | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Restart observer to auto-attach, by default None.</p> </li> <li> <code>logging_interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Interval at which to call the observers, by default 1.</p> </li> <li> <code>logging_mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>Mode in which to open the observers, by default \"a\".</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>__seed</code>               (<code>Final[int]</code>)           \u2013            <p>The seed used for the random number generator, initialized to a random value if not provided.</p> </li> <li> <code>_rng</code>               (<code>Generator</code>)           \u2013            <p>Random number generator.</p> </li> <li> <code>acceptance_rate</code>               (<code>float</code>)           \u2013            <p>The acceptance rate of the moves in the simulation, initialized to 0.0.</p> </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>Context object for the simulation used to store the state of the simulation and provide information to the moves/criteria.</p> </li> <li> <code>default_logger</code>               (<code>Logger | None</code>)           \u2013            <p>Default logger object.</p> </li> <li> <code>default_criteria</code>               (<code>ClassVar[dict[type[MoveProtocol], type[Criteria]]]</code>)           \u2013            <p>Dictionary mapping move types to their default criteria classes.</p> </li> <li> <code>default_context</code>               (<code>ClassVar[type[Context]]</code>)           \u2013            <p>The default context type for this Monte Carlo simulation.</p> </li> <li> <code>last_results</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The last results of the simulation, typically the calculator results from the Atoms object.</p> </li> <li> <code>max_cycles</code>               (<code>int</code>)           \u2013            <p>Number of Monte Carlo cycles per step.</p> </li> <li> <code>move_history</code>               (<code>list[tuple[str, bool | None]]</code>)           \u2013            <p>History of moves performed in the current step, where each entry is a tuple of the move name and whether it was accepted (True), rejected (False), or not attempted (None).</p> </li> <li> <code>moves</code>               (<code>dict[str, MoveStorage[MoveType, CriteriaType]]</code>)           \u2013            <p>A dictionary of moves to perform, where the key is the name of the move and the value is a <code>MoveStorage</code> object containing the move, its criteria, interval, probability, and minimum count.</p> </li> <li> <code>step_count</code>               (<code>int</code>)           \u2013            <p>The number of steps performed in the simulation, initialized to 0.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    max_cycles: int = 1,\n    seed: int | None = None,\n    logfile: Logger | IO | Path | str | None = None,\n    trajectory: TrajectoryObserver | IO | Path | str | None = None,\n    restart_file: RestartObserver | IO | Path | str | None = None,\n    logging_interval: int = 1,\n    logging_mode: str = \"a\",\n) -&gt; None:\n    \"\"\"Initialize the MonteCarlo object.\"\"\"\n    self.moves: dict[str, MoveStorage[MoveType, CriteriaType]] = {}\n\n    self.__seed: Final = seed or PCG64().random_raw()\n    self._rng = RNG(PCG64(self.__seed))\n\n    self.max_cycles = max_cycles\n\n    self.acceptance_rate = 0.0\n    self.move_history: list[tuple[str, bool | None]] = []\n\n    self.context = self.default_context(atoms, self._rng)\n\n    super().__init__(\n        atoms,\n        logfile=logfile,\n        trajectory=trajectory,\n        restart_file=restart_file,\n        logging_interval=logging_interval,\n        logging_mode=logging_mode,\n    )\n\n    if self.default_logger:\n        self.default_logger.add_mc_fields(self)\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return a string representation of the Monte Carlo object.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string representation of the Monte Carlo object.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the Monte Carlo object.\n\n    Returns\n    -------\n    str\n        A string representation of the Monte Carlo object.\n    \"\"\"\n    return f\"{self.__class__.__name__}(atoms={self.atoms}, max_cycles={self.max_cycles}, seed={self.__seed}, moves={self.moves}, step_count={self.step_count}, default_logger={self.default_logger}, default_trajectory={self.default_trajectory}, default_restart={self.default_restart})\"\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.add_move","title":"add_move","text":"<pre><code>add_move(move, criteria=None, name='default', interval=1, probability=1.0, minimum_count=0)\n</code></pre> <p>Add a move to the <code>MonteCarlo</code> object.</p> <p>Parameters:</p> <ul> <li> <code>move</code>               (<code>MoveType</code>)           \u2013            <p>The move to add to the <code>MonteCarlo</code> object.</p> </li> <li> <code>criteria</code>               (<code>CriteriaType | None</code>, default:                   <code>None</code> )           \u2013            <p>The acceptance criteria for the move, by default None. If None, the move must be an instance of a known move type.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'default'</code> )           \u2013            <p>Name of the move, used to identify the move in the <code>moves</code> dictionary, by default \"default\".</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The interval at which the move is attempted, by default 1.</p> </li> <li> <code>probability</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The probability of the move being attempted, by default 1.0.</p> </li> <li> <code>minimum_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum number of times the move must be performed, by default 0.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def add_move(\n    self,\n    move: MoveType,\n    criteria: CriteriaType | None = None,\n    name: str = \"default\",\n    interval: int = 1,\n    probability: float = 1.0,\n    minimum_count: int = 0,\n) -&gt; None:\n    \"\"\"\n    Add a move to the `MonteCarlo` object.\n\n    Parameters\n    ----------\n    move : MoveType\n        The move to add to the `MonteCarlo` object.\n    criteria : CriteriaType | None, optional\n        The acceptance criteria for the move, by default None. If None, the move must be an instance of a known move type.\n    name : str, optional\n        Name of the move, used to identify the move in the `moves` dictionary, by default \"default\".\n    interval : int, optional\n        The interval at which the move is attempted, by default 1.\n    probability : float, optional\n        The probability of the move being attempted, by default 1.0.\n    minimum_count : int, optional\n        The minimum number of times the move must be performed, by default 0.\n    \"\"\"\n    forced_moves_count = sum(\n        [self.moves[name].minimum_count for name in self.moves]\n    )\n\n    if forced_moves_count + minimum_count &gt; self.max_cycles:\n        raise ValueError(\"The number of forced moves exceeds the number of cycles.\")\n\n    if criteria is None:\n        for move_type in self.default_criteria:\n            if isinstance(move, move_type):\n                criteria = cast(\"CriteriaType\", self.default_criteria[move_type]())\n                break\n\n    if criteria is None:\n        raise ValueError(\n            f\"No criteria provided, and no default criteria found for move type {type(move)}.\"\n        )\n\n    self.moves[name] = MoveStorage[MoveType, CriteriaType](\n        move=move,\n        criteria=criteria,\n        interval=interval,\n        probability=probability,\n        minimum_count=minimum_count,\n    )\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data, **kwargs_override)\n</code></pre> <p>Create a <code>MonteCarlo</code> object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the object.</p> </li> <li> <code>**kwargs_override</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to override the ones in the dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>MonteCarlo</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any], **kwargs_override: Any) -&gt; Self:\n    \"\"\"\n    Create a `MonteCarlo` object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the object.\n    **kwargs_override : Any\n        Additional keyword arguments to override the ones in the dictionary.\n\n    Returns\n    -------\n    Self\n        The `MonteCarlo` object created from the dictionary.\n    \"\"\"\n    data = deepcopy(data)\n\n    kwargs = data.get(\"kwargs\", {})\n    kwargs = kwargs | kwargs_override\n\n    mc = cls(data[\"atoms\"], **kwargs)\n    mc._rng.bit_generator.state = data[\"rng_state\"]\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(mc, key, value)\n\n    for key, value in data.get(\"context\", {}).items():\n        setattr(mc.context, key, value)\n\n    for name, move_storage_data in data.get(\"moves\", {}).items():\n        move_storage_class: type[MoveStorage[MoveType, CriteriaType]] = (\n            get_typed_class(move_storage_data[\"name\"], MoveStorage)\n        )\n        move_storage = move_storage_class.from_dict(move_storage_data)\n\n        mc.moves[name] = move_storage\n\n    return mc\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the last move made by the simulation. This method is called when a move is rejected.</p> Source code in <code>quansino/mc/core.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the last move made by the simulation. This method is called when a move is rejected.\n    \"\"\"\n    self.context.revert_state()\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.run","title":"run","text":"<pre><code>run(steps=100000000)\n</code></pre> <p>Run the simulation for a given number of steps.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>int</code>, default:                   <code>100000000</code> )           \u2013            <p>The number of steps to run the simulation for, by default 100,000,000.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def run(self, steps=100_000_000) -&gt; None:\n    \"\"\"\n    Run the simulation for a given number of steps.\n\n    Parameters\n    ----------\n    steps : int, optional\n        The number of steps to run the simulation for, by default 100,000,000.\n    \"\"\"\n    for step in self.irun(steps):\n        for _ in step:\n            pass\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the simulation. This method is called when a move is accepted.</p> Source code in <code>quansino/mc/core.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the simulation. This method is called when a move is accepted.\n    \"\"\"\n    self.context.save_state()\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.srun","title":"srun","text":"<pre><code>srun(steps=100000000)\n</code></pre> <p>Run the simulation for a given number of steps, yielding the steps.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>int</code>, default:                   <code>100000000</code> )           \u2013            <p>The number of steps to run the simulation for, by default 100,000,000.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator[Any, None, None]</code>           \u2013            <p>A <code>Generator</code> yielding the steps of the simulation.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def srun(self, steps=100_000_000) -&gt; Generator[Any, None, None]:\n    \"\"\"\n    Run the simulation for a given number of steps, yielding the steps.\n\n    Parameters\n    ----------\n    steps : int, optional\n        The number of steps to run the simulation for, by default 100,000,000.\n\n    Yields\n    ------\n    Generator[Any, None, None]\n        A `Generator` yielding the steps of the simulation.\n    \"\"\"\n    for step in self.irun(steps):\n        for _ in step:\n            pass\n\n        yield step\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Perform a single step of the simulation.</p> <p>Yields:</p> <ul> <li> <code>Generator[str, None, None]</code>           \u2013            <p>A generator yielding the names of the moves that will be performed in this step.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def step(self) -&gt; Generator[str, None, None]:\n    \"\"\"\n    Perform a single step of the simulation.\n\n    Yields\n    ------\n    Generator[str, None, None]\n        A generator yielding the names of the moves that will be performed in this step.\n    \"\"\"\n    self.move_history = []\n\n    for move_name in self.yield_moves():\n        yield move_name\n\n        move_storage = self.moves[move_name]\n        move = move_storage.move\n\n        if move(self.context):\n            is_accepted = move_storage.criteria.evaluate(self.context)\n\n            if is_accepted:\n                self.save_state()\n            else:\n                self.revert_state()\n        else:\n            is_accepted = None\n\n        self.move_history.append((move_name, is_accepted))\n\n    self.acceptance_rate = np.mean(\n        [1 if is_accepted else 0 for _, is_accepted in self.move_history]\n    )\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>MonteCarlo</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>MonteCarlo</code> object.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `MonteCarlo` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `MonteCarlo` object.\n    \"\"\"\n    dictionary = {\n        **super().to_dict(),\n        \"name\": self.__class__.__name__,\n        \"context\": self.context.to_dict(),\n        \"rng_state\": self._rng.bit_generator.state,\n        \"moves\": {\n            name: move_storage.to_dict()\n            for name, move_storage in self.moves.items()\n        },\n    }\n\n    dictionary.setdefault(\"kwargs\", {}).update(\n        {\"max_cycles\": self.max_cycles, \"seed\": self.__seed}\n    )\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.validate_simulation","title":"validate_simulation","text":"<pre><code>validate_simulation()\n</code></pre> <p>Validate the simulation setup. Checks that moves have been added to the Monte Carlo simulation and that the Atoms object has a calculator with results.</p> Source code in <code>quansino/mc/core.py</code> <pre><code>def validate_simulation(self) -&gt; None:\n    \"\"\"\n    Validate the simulation setup. Checks that moves have been added to the Monte Carlo simulation and that the Atoms object has a calculator with results.\n    \"\"\"\n    if len(self.moves) == 0:\n        warn(\n            \"No moves have been added to the Monte Carlo simulation. \"\n            \"Please add moves using the `add_move` method.\",\n            UserWarning,\n            2,\n        )\n\n    try:\n        self.context.last_results = self.atoms.calc.results  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\n            \"Atoms object does not have calculator attached, or does not support the `results` attribute.\",\n            UserWarning,\n            2,\n        )\n        self.context.last_results = {}\n\n    super().validate_simulation()\n</code></pre>"},{"location":"reference/quansino/mc/core.html#quansino.mc.core.MonteCarlo.yield_moves","title":"yield_moves","text":"<pre><code>yield_moves()\n</code></pre> <p>Yield moves to be performed given the move configured. The moves are selected based on their probability, and their interval. Forced moves are introduced based on their minimum count. Moves are yielded separately, re-constructing the move_probabilities array each time, allowing for a dynamic change in the probability of moves between moves.</p> <p>Yields:</p> <ul> <li> <code>Generator[str, None, None]</code>           \u2013            <p>The name of the move to be performed.</p> </li> </ul> Source code in <code>quansino/mc/core.py</code> <pre><code>def yield_moves(self) -&gt; Generator[str, None, None]:\n    \"\"\"\n    Yield moves to be performed given the move configured. The moves are selected based on their probability, and their interval. Forced moves are introduced based on their minimum count. Moves are yielded separately, re-constructing the move_probabilities array each time, allowing for a dynamic change in the probability of moves between moves.\n\n    Yields\n    ------\n    Generator[str, None, None]\n        The name of the move to be performed.\n    \"\"\"\n    available_moves: list[str] = [\n        name\n        for name in self.moves\n        if self.step_count % self.moves[name].interval == 0\n    ]\n\n    if not available_moves:\n        return\n\n    counts = [self.moves[name].minimum_count for name in available_moves]\n    forced_moves = np.repeat(available_moves, counts)\n    forced_moves_index = self._rng.choice(\n        np.arange(self.max_cycles), size=len(forced_moves), replace=False\n    )\n    forced_moves_mapping = dict(zip(forced_moves_index, forced_moves, strict=True))\n\n    for index in range(self.max_cycles):\n        if index in forced_moves_mapping:\n            yield forced_moves_mapping[index]\n        else:\n            move_probabilities = np.array(\n                [self.moves[name].probability for name in available_moves]\n            )\n            move_probabilities /= np.sum(move_probabilities)\n\n            selected_move = self._rng.choice(available_moves, p=move_probabilities)\n\n            yield selected_move\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html","title":"criteria","text":""},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.BaseCriteria","title":"BaseCriteria","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for acceptance criteria, it defines the interface for acceptance criteria used in simulations. Implementations must provide an <code>evaluate</code> method that determines whether a move is accepted or rejected.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.BaseCriteria.evaluate","title":"evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(context, *args, **kwargs)\n</code></pre> <p>Evaluate whether a Monte Carlo move should be accepted. This method should be implemented in subclasses.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The simulation context containing information about the current state.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments passed to the method.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments passed to the method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>@abstractmethod\ndef evaluate(self, context: Context, *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Evaluate whether a Monte Carlo move should be accepted. This method should be implemented in subclasses.\n\n    Parameters\n    ----------\n    context : Context\n        The simulation context containing information about the current state.\n    *args : Any\n        Positional arguments passed to the method.\n    **kwargs : Any\n        Keyword arguments passed to the method.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.BaseCriteria.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create a <code>BaseCriteria</code> object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the <code>BaseCriteria</code> object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BaseCriteria</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create a `BaseCriteria` object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the `BaseCriteria` object.\n\n    Returns\n    -------\n    Self\n        The `BaseCriteria` object created from the dictionary.\n    \"\"\"\n    kwargs = data.get(\"kwargs\", {})\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.BaseCriteria.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>BaseCriteria</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>BaseCriteria</code> object.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `BaseCriteria` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `BaseCriteria` object.\n    \"\"\"\n    return {\"name\": self.__class__.__name__}\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.CanonicalCriteria","title":"CanonicalCriteria","text":"<p>               Bases: <code>BaseCriteria</code></p> <p>Acceptance criteria for Monte Carlo simulation in the canonical (NVT) ensemble.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.CanonicalCriteria.evaluate","title":"evaluate  <code>staticmethod</code>","text":"<pre><code>evaluate(context)\n</code></pre> <p>Evaluate the acceptance criteria.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The context of the Monte Carlo simulation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>@staticmethod\ndef evaluate(context: DisplacementContext) -&gt; bool:\n    \"\"\"\n    Evaluate the acceptance criteria.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The context of the Monte Carlo simulation.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    energy_difference = (\n        context.atoms.get_potential_energy() - context.last_potential_energy\n    )\n\n    return context.rng.random() &lt; math.exp(\n        -energy_difference / (context.temperature * kB)\n    )\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.GrandCanonicalCriteria","title":"GrandCanonicalCriteria","text":"<p>               Bases: <code>BaseCriteria</code></p> <p>Acceptance criteria for Monte Carlo moves in the grand canonical (\u03bcVT) ensemble.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.GrandCanonicalCriteria.evaluate","title":"evaluate","text":"<pre><code>evaluate(context)\n</code></pre> <p>Evaluate the acceptance criteria for a Monte Carlo move.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ExchangeContext</code>)           \u2013            <p>The context of the Monte Carlo simulation containing exchange-specific information such as added/deleted atoms, chemical potential, and accessible volume.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>def evaluate(self, context: ExchangeContext) -&gt; bool:\n    \"\"\"\n    Evaluate the acceptance criteria for a Monte Carlo move.\n\n    Parameters\n    ----------\n    context : ExchangeContext\n        The context of the Monte Carlo simulation containing exchange-specific information such as added/deleted atoms, chemical potential, and accessible volume.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    energy_difference = (\n        context.atoms.get_potential_energy() - context.last_potential_energy\n    )\n\n    number_of_exchange_particles = context.number_of_exchange_particles\n    mass = context.exchange_atoms.get_masses().sum()\n    particle_delta = context.particle_delta\n\n    volume = context.accessible_volume**particle_delta\n\n    factorial_term = 1\n    if particle_delta &gt; 0:\n        for i in range(\n            number_of_exchange_particles + 1,\n            number_of_exchange_particles + particle_delta + 1,\n        ):\n            factorial_term /= i\n    elif particle_delta &lt; 0:\n        for i in range(\n            number_of_exchange_particles + particle_delta + 1,\n            number_of_exchange_particles + 1,\n        ):\n            factorial_term *= i\n\n    debroglie_wavelength = (\n        math.sqrt(\n            _hplanck**2\n            / (2 * np.pi * mass * kB * context.temperature / _Nav * 1e-3 * _e)\n        )\n        * 1e10\n    ) ** (-3 * particle_delta)\n\n    prefactor = volume * factorial_term * debroglie_wavelength\n    exponential = (\n        particle_delta * context.chemical_potential - energy_difference\n    ) / (context.temperature * kB)\n\n    criteria = math.exp(exponential)\n    return context.rng.random() &lt; criteria * prefactor\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.HamiltonianCanonicalCriteria","title":"HamiltonianCanonicalCriteria","text":"<p>               Bases: <code>BaseCriteria</code></p> <p>Acceptance criteria for hybrid Monte Carlo simulation in the canonical (NVT) ensemble.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.HamiltonianCanonicalCriteria.evaluate","title":"evaluate  <code>staticmethod</code>","text":"<pre><code>evaluate(context)\n</code></pre> <p>Evaluate the acceptance criteria.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>HMCDisplacementContext</code>)           \u2013            <p>The context of the Monte Carlo simulation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>@staticmethod\ndef evaluate(context: HamiltonianDisplacementContext) -&gt; bool:\n    \"\"\"\n    Evaluate the acceptance criteria.\n\n    Parameters\n    ----------\n    context : HMCDisplacementContext\n        The context of the Monte Carlo simulation.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    energy_difference = (\n        context.atoms.get_total_energy()\n        - context.last_potential_energy\n        - context.last_kinetic_energy\n    )\n\n    return context.rng.random() &lt; math.exp(\n        -energy_difference / (context.temperature * kB)\n    )\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.IsobaricCriteria","title":"IsobaricCriteria","text":"<p>               Bases: <code>BaseCriteria</code></p> <p>Acceptance criteria for moves in the isothermal-isobaric (NPT) ensemble.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.IsobaricCriteria.evaluate","title":"evaluate  <code>staticmethod</code>","text":"<pre><code>evaluate(context)\n</code></pre> <p>Evaluate the acceptance criteria for a Monte Carlo move.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DeformationContext</code>)           \u2013            <p>The context of the Monte Carlo simulation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>@staticmethod\ndef evaluate(context: DeformationContext) -&gt; bool:\n    \"\"\"\n    Evaluate the acceptance criteria for a Monte Carlo move.\n\n    Parameters\n    ----------\n    context : DeformationContext\n        The context of the Monte Carlo simulation.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    atoms = context.atoms\n    temperature = context.temperature * kB\n    energy_difference = atoms.get_potential_energy() - context.last_potential_energy\n\n    current_volume = atoms.get_volume()\n    old_volume = context.last_cell.volume\n\n    return context.rng.random() &lt; math.exp(\n        -(energy_difference + context.pressure * (current_volume - old_volume))\n        / temperature\n        + (len(atoms) + 1) * np.log(current_volume / old_volume)\n    )\n</code></pre>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.IsotensionCriteria","title":"IsotensionCriteria","text":"<p>               Bases: <code>BaseCriteria</code></p> <p>Acceptance criteria for moves in the isothermal-isotension (NST) ensemble.</p>"},{"location":"reference/quansino/mc/criteria.html#quansino.mc.criteria.IsotensionCriteria.evaluate","title":"evaluate","text":"<pre><code>evaluate(context)\n</code></pre> <p>Evaluate the acceptance criteria for a Monte Carlo move.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DeformationContext</code>)           \u2013            <p>The context of the Monte Carlo simulation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the move is accepted, False otherwise.</p> </li> </ul> Source code in <code>quansino/mc/criteria.py</code> <pre><code>def evaluate(self, context: DeformationContext) -&gt; bool:\n    \"\"\"\n    Evaluate the acceptance criteria for a Monte Carlo move.\n\n    Parameters\n    ----------\n    context : DeformationContext\n        The context of the Monte Carlo simulation.\n\n    Returns\n    -------\n    bool\n        True if the move is accepted, False otherwise.\n    \"\"\"\n    atoms = context.atoms\n    temperature = context.temperature * kB\n    energy_difference = atoms.get_potential_energy() - context.last_potential_energy\n\n    current_cell = atoms.get_cell().array\n    old_cell = context.last_cell.array\n\n    current_volume = atoms.cell.volume\n    old_volume = context.last_cell.volume\n\n    self.strain_tensor = 0.5 * (\n        np.linalg.inv(old_cell.T)\n        @ current_cell.T\n        @ old_cell\n        @ np.linalg.inv(old_cell)\n        - np.eye(3)\n    )\n\n    elastic_energy = context.pressure * (\n        current_volume - old_volume\n    ) + old_volume * np.trace(\n        (context.external_stress - context.pressure) @ self.strain_tensor\n    )\n\n    return context.rng.random() &lt; math.exp(\n        -(energy_difference + elastic_energy) / temperature\n        + (len(atoms) + 1) * np.log(atoms.get_volume() / context.last_cell.volume)\n    )\n</code></pre>"},{"location":"reference/quansino/mc/driver.html","title":"driver","text":""},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver","title":"Driver","text":"<pre><code>Driver(atoms, logfile=None, trajectory=None, restart_file=None, logging_interval=1, logging_mode='a')\n</code></pre> <p>Base class for managing atomistic simulations. This class provides the basic functionality for running simulations, including observer management, file I/O handling, and simulation state tracking. It is not intended to be used directly, but rather as a base class for specific simulation implementations.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object to operate on.</p> </li> <li> <code>logfile</code>               (<code>Logger | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Logger observer to auto-attach, by default None.</p> </li> <li> <code>trajectory</code>               (<code>TrajectoryObserver | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Trajectory observer to auto-attach, by default None.</p> </li> <li> <code>restart_file</code>               (<code>RestartObserver | IO | Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Restart observer to auto-attach, by default None.</p> </li> <li> <code>logging_interval</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Interval at which to call the observers, by default 1.</p> </li> <li> <code>logging_mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>Mode in which to open the observers, by default \"a\".</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object being simulated.</p> </li> <li> <code>observers</code>               (<code>dict[str, Observer]</code>)           \u2013            <p>Dictionary of attached observers, keyed by their names.</p> </li> <li> <code>logging_interval</code>               (<code>int</code>)           \u2013            <p>The interval at which observers are called.</p> </li> <li> <code>logging_mode</code>               (<code>str</code>)           \u2013            <p>The file mode for opening log files.</p> </li> <li> <code>step_count</code>               (<code>int</code>)           \u2013            <p>The current step count of the simulation.</p> </li> <li> <code>max_steps</code>               (<code>int</code>)           \u2013            <p>The maximum number of steps to run in the simulation.</p> </li> <li> <code>file_manager</code>               (<code>FileManager</code>)           \u2013            <p>File manager for handling file I/O operations.</p> </li> <li> <code>default_logger</code>               (<code>Logger | None</code>)           \u2013            <p>The default logger for the simulation, if set.</p> </li> <li> <code>default_trajectory</code>               (<code>TrajectoryObserver | None</code>)           \u2013            <p>The default trajectory observer for the simulation, if set.</p> </li> <li> <code>default_restart</code>               (<code>RestartObserver | None</code>)           \u2013            <p>The default restart observer for the simulation, if set.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    logfile: Logger | IO | Path | str | None = None,\n    trajectory: TrajectoryObserver | IO | Path | str | None = None,\n    restart_file: RestartObserver | IO | Path | str | None = None,\n    logging_interval: int = 1,\n    logging_mode: str = \"a\",\n) -&gt; None:\n    \"\"\"Initialize the `Driver` object.\"\"\"\n    self.atoms = atoms\n\n    self.observers: dict[str, Observer] = {}\n\n    self.logging_interval = logging_interval\n    self.logging_mode = logging_mode\n\n    self.step_count: int = 0\n    self.max_steps: int = 0\n\n    self.file_manager: Final = FileManager()\n\n    self.default_logger = logfile\n    self.default_trajectory = trajectory\n    self.default_restart = restart_file\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.default_logger","title":"default_logger  <code>property</code> <code>writable</code>","text":"<pre><code>default_logger\n</code></pre> <p>Get the default logger, if set.</p> <p>Returns:</p> <ul> <li> <code>Logger | None</code>           \u2013            <p>The default logger, or None if not set.</p> </li> </ul>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.default_restart","title":"default_restart  <code>property</code> <code>writable</code>","text":"<pre><code>default_restart\n</code></pre> <p>Get the default restart observer, if set.</p> <p>Returns:</p> <ul> <li> <code>RestartObserver | None</code>           \u2013            <p>The default restart observer, or None if not set.</p> </li> </ul>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.default_trajectory","title":"default_trajectory  <code>property</code> <code>writable</code>","text":"<pre><code>default_trajectory\n</code></pre> <p>Get the default trajectory observer, if set.</p> <p>Returns:</p> <ul> <li> <code>TrajectoryObserver | None</code>           \u2013            <p>The default trajectory observer, or None if not set.</p> </li> </ul>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.attach_observer","title":"attach_observer","text":"<pre><code>attach_observer(name, observer)\n</code></pre> <p>Attach an observer to the simulation.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the observer.</p> </li> <li> <code>observer</code>               (<code>Observer</code>)           \u2013            <p>The observer object to attach. Must be a subclass of <code>Observer</code>.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def attach_observer(self, name: str, observer: Observer) -&gt; None:\n    \"\"\"\n    Attach an observer to the simulation.\n\n    Parameters\n    ----------\n    name : str\n        The name of the observer.\n    observer : Observer\n        The observer object to attach. Must be a subclass of `Observer`.\n    \"\"\"\n    observer.attach_simulation(self.file_manager)\n    self.observers[name] = observer\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.call_observers","title":"call_observers","text":"<pre><code>call_observers()\n</code></pre> <p>Call all attached observers based on their configured intervals. The observers will be called if their interval matches the current step count.</p> Source code in <code>quansino/mc/driver.py</code> <pre><code>def call_observers(self) -&gt; None:\n    \"\"\"\n    Call all attached observers based on their configured intervals. The observers will be called if their interval matches the current step count.\n    \"\"\"\n    for observer in self.observers.values():\n        interval = observer.interval\n        if (interval &gt; 0 and self.step_count % interval == 0) or (\n            interval &lt; 0 and self.step_count == abs(interval)\n        ):\n            observer()\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the file manager and clean up resources.</p> Source code in <code>quansino/mc/driver.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the file manager and clean up resources.\"\"\"\n    self.file_manager.close()\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.converged","title":"converged","text":"<pre><code>converged()\n</code></pre> <p>Check if the simulation has converged.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the maximum number of steps has been reached.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def converged(self) -&gt; bool:\n    \"\"\"\n    Check if the simulation has converged.\n\n    Returns\n    -------\n    bool\n        True if the maximum number of steps has been reached.\n    \"\"\"\n    return self.step_count &gt;= self.max_steps\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.detach_observer","title":"detach_observer","text":"<pre><code>detach_observer(name)\n</code></pre> <p>Detach an observer by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the observer to detach.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def detach_observer(self, name: str) -&gt; None:\n    \"\"\"\n    Detach an observer by name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the observer to detach.\n    \"\"\"\n    if self.observers.pop(name, None) is None:\n        warn(f\"`Observer` '{name}' not found when deleting.\", UserWarning, 2)\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.irun","title":"irun","text":"<pre><code>irun(steps=100000000)\n</code></pre> <p>Run the simulation as a <code>Generator</code>.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>int</code>, default:                   <code>100000000</code> )           \u2013            <p>Maximum number of simulation steps to perform, by default 100,000,000.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Generator[Any, None, None]</code>           \u2013            <p>The result of each simulation step.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def irun(self, steps=100_000_000) -&gt; Generator[Any, None, None]:\n    \"\"\"\n    Run the simulation as a `Generator`.\n\n    Parameters\n    ----------\n    steps : int\n        Maximum number of simulation steps to perform, by default 100,000,000.\n\n    Yields\n    ------\n    Generator[Any, None, None]\n        The result of each simulation step.\n    \"\"\"\n    self.validate_simulation()\n    self.max_steps = self.step_count + steps\n\n    if self.step_count == 0:\n        if self.default_logger:\n            self.default_logger.write_header()\n\n        self.call_observers()\n\n    while not self.converged():\n        yield self.step()\n        self.step_count += 1\n\n        self.atoms.get_potential_energy()\n\n        self.call_observers()\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.run","title":"run","text":"<pre><code>run(steps=100000000)\n</code></pre> <p>Run the simulation for a given number of steps.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>int</code>, default:                   <code>100000000</code> )           \u2013            <p>Maximum number of simulation steps to perform, by default 100,000,000.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def run(self, steps=100_000_000) -&gt; None:\n    \"\"\"\n    Run the simulation for a given number of steps.\n\n    Parameters\n    ----------\n    steps : int, optional\n        Maximum number of simulation steps to perform, by default 100,000,000.\n    \"\"\"\n    for _ in self.irun(steps):\n        pass\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Perform a single step.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Result of the Monte Carlo step. Implementation-dependent.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def step(self) -&gt; Any:\n    \"\"\"\n    Perform a single step.\n\n    Returns\n    -------\n    Any\n        Result of the Monte Carlo step. Implementation-dependent.\n    \"\"\"\n    raise NotImplementedError(\n        f\"The `step` method must be implemented in subclasses of {self.__class__.__name__}.\"\n    )\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary representation of the <code>Driver</code> object.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>Driver</code> object.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Return a dictionary representation of the `Driver` object.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `Driver` object.\n    \"\"\"\n    return {\n        \"name\": self.__class__.__name__,\n        \"atoms\": self.atoms.copy(),\n        \"kwargs\": {\n            \"logging_interval\": self.logging_interval,\n            \"logging_mode\": self.logging_mode,\n        },\n        \"attributes\": {\"step_count\": self.step_count},\n    }\n</code></pre>"},{"location":"reference/quansino/mc/driver.html#quansino.mc.driver.Driver.validate_simulation","title":"validate_simulation","text":"<pre><code>validate_simulation()\n</code></pre> <p>Validate the simulation setup. Checks that the atoms object has a properly configured calculator and computes the initial potential energy.</p> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If atoms object has no calculator or calculator has no results attribute.</p> </li> </ul> Source code in <code>quansino/mc/driver.py</code> <pre><code>def validate_simulation(self) -&gt; None:\n    \"\"\"\n    Validate the simulation setup. Checks that the atoms object has a properly configured calculator and computes the initial potential energy.\n\n    Raises\n    ------\n    AttributeError\n        If atoms object has no calculator or calculator has no results attribute.\n    \"\"\"\n    if self.atoms.calc is None:\n        raise AttributeError(\"Atoms object must have a calculator attached to it.\")\n    if not hasattr(self.atoms.calc, \"results\"):\n        raise AttributeError(\"Calculator object must have a results attribute.\")\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html","title":"fbmc","text":"<p>Module to perform force bias Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias","title":"AdaptiveForceBias","text":"<pre><code>AdaptiveForceBias(atoms, min_delta, max_delta, temperature=298.15, scheme='forces', reference_variance=0.1, update_function='tanh', **mc_kwargs)\n</code></pre> <p>               Bases: <code>ForceBias</code></p> <p>Adaptive Force Bias Monte Carlo class to perform simulations with adaptive delta parameter. The delta parameter is adjusted based on the variation coefficient of the forces or energies which is calculated based on the variance of the forces or energies. The current class assume that the forces or energies are calculated by a committee of MACECalculator.</p> <pre><code>model_paths = [\"path/to/model_0\", \"path/to/model_1\", \"path/to/model_2\"]\nmace_calcs = MACECalculator(model_paths=model_paths)\n</code></pre> <p>The variation of the <code>delta</code> parameter allow the simulation to explore the phase space more efficiently based on the variance of the forces or energies. The <code>delta</code> parameter is adjusted based on the following formula:</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atomic system being simulated.</p> </li> <li> <code>min_delta</code>               (<code>float</code>)           \u2013            <p>Minimum delta parameter in Angstrom.</p> </li> <li> <code>max_delta</code>               (<code>float</code>)           \u2013            <p>Maximum delta parameter in Angstrom.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>The temperature of the simulation in Kelvin. Default: 298.15.</p> </li> <li> <code>scheme</code>               (<code>Literal['forces', 'energy']</code>, default:                   <code>'forces'</code> )           \u2013            <p>Scheme to use for variation coefficient calculation. Default: \"forces\".</p> </li> <li> <code>reference_variance</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Reference variance for the variation coefficient. Default: 0.1.</p> </li> <li> <code>update_function</code>               (<code>str</code>, default:                   <code>'tanh'</code> )           \u2013            <p>Update function to use for delta parameter adjustment. Default: \"tanh\".</p> </li> <li> <code>**mc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the ForceBias superclass.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    min_delta: float,\n    max_delta: float,\n    temperature: float = 298.15,\n    scheme: Literal[\"forces\", \"energy\"] = \"forces\",\n    reference_variance: float = 0.1,\n    update_function: str = \"tanh\",\n    **mc_kwargs,\n):\n    self.reference_variance = reference_variance\n\n    self.min_delta = min_delta\n    self.max_delta = max_delta\n\n    self.schemes = {\n        \"forces\": self.get_forces_variation_coef,\n        \"energy\": self.get_energy_variation_coef,\n    }\n    self.scheme = scheme\n\n    self.update_functions = {\"tanh\": self.tanh_update, \"exp\": self.exp_update}\n    self.update_function = update_function\n\n    self.variation_coef: NDArray[np.floating] | float = 0.0\n\n    super().__init__(\n        atoms, (self.min_delta + self.max_delta) / 2, temperature, **mc_kwargs\n    )\n\n    if self.default_logger:\n        if self.scheme == \"forces\":\n            self.default_logger.add_field(\n                \"MeanDelta\", lambda: np.mean(self.delta), str_format=\"{:&gt;16.2f}\"\n            )\n            self.default_logger.add_field(\n                \"MinDelta\", lambda: np.min(self.delta), str_format=\"{:&gt;16.2f}\"\n            )\n            self.default_logger.add_field(\n                \"MaxDelta\", lambda: np.max(self.delta), str_format=\"{:&gt;16.2f}\"\n            )\n            self.default_logger.add_field(\n                \"MeanForcesVar\",\n                lambda: np.mean(self.variation_coef),\n                str_format=\"{:&gt;16.6f}\",\n            )\n        elif self.scheme == \"energy\":\n            self.default_logger.add_field(\n                \"Delta\", lambda: self.delta, str_format=\"{:&gt;16.2f}\"\n            )\n            self.default_logger.add_field(\n                \"EnergyVar\", lambda: self.variation_coef, str_format=\"{:&gt;16.6f}\"\n            )\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.exp_update","title":"exp_update","text":"<pre><code>exp_update(variation_coefficient)\n</code></pre> <p>Update function using the exponential function.</p> <p>Parameters:</p> <ul> <li> <code>variation_coefficient</code>               (<code>float</code>)           \u2013            <p>The variation coefficient.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | NDArray[floating]</code>           \u2013            <p>The updated value based on the exponential function.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def exp_update(self, variation_coefficient: float) -&gt; float | NDArray[np.floating]:\n    \"\"\"\n    Update function using the exponential function.\n\n    Parameters\n    ----------\n    variation_coefficient: float\n        The variation coefficient.\n\n    Returns\n    -------\n    float | NDArray[np.floating]\n        The updated value based on the exponential function.\n    \"\"\"\n    return np.exp(-variation_coefficient / self.reference_variance * math.log(2))\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.get_energy_variation_coef","title":"get_energy_variation_coef","text":"<pre><code>get_energy_variation_coef(atoms)\n</code></pre> <p>Calculate the variation coefficient based on committee energies.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atomic system being simulated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The variation coefficient for the energies.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def get_energy_variation_coef(self, atoms: Atoms) -&gt; float:\n    \"\"\"\n    Calculate the variation coefficient based on committee energies.\n\n    Parameters\n    ----------\n    atoms: Atoms\n        The atomic system being simulated.\n\n    Returns\n    -------\n    float\n        The variation coefficient for the energies.\n    \"\"\"\n    try:\n        energies_committee = atoms.calc.results[self.energies_variance_keyword]  # type: ignore[try-attr]\n\n        return np.std(energies_committee, axis=0) / len(atoms)\n    except (KeyError, AttributeError):\n        warn(\n            \"No committee energies available, using default reference variance.\",\n            stacklevel=2,\n        )\n\n        return self.reference_variance\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.get_forces_variation_coef","title":"get_forces_variation_coef","text":"<pre><code>get_forces_variation_coef(atoms)\n</code></pre> <p>Calculate the variation coefficient based on committee forces.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atomic system being simulated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The variation coefficient for the forces.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def get_forces_variation_coef(self, atoms: Atoms) -&gt; NDArray:\n    \"\"\"\n    Calculate the variation coefficient based on committee forces.\n\n    Parameters\n    ----------\n    atoms: Atoms\n        The atomic system being simulated.\n\n    Returns\n    -------\n    NDArray\n        The variation coefficient for the forces.\n    \"\"\"\n    try:\n        forces_committee = atoms.calc.results[self.forces_variance_keyword]  # type: ignore[try-attr]\n        return np.std(forces_committee, axis=0) / np.mean(\n            np.abs(forces_committee), axis=0\n        )\n    except (KeyError, AttributeError):\n        warn(\n            \"No committee forces available, using default reference variance.\",\n            stacklevel=2,\n        )\n        return np.full((len(atoms), 3), self.reference_variance)\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Perform one Adaptive Force Bias Monte Carlo step.</p> <p>Returns:</p> <ul> <li> <code>Forces</code>           \u2013            <p>The forces acting on the atoms after the Monte Carlo step.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def step(self) -&gt; Forces:\n    \"\"\"\n    Perform one Adaptive Force Bias Monte Carlo step.\n\n    Returns\n    -------\n    Forces\n        The forces acting on the atoms after the Monte Carlo step.\n    \"\"\"\n    self.update_delta()\n    return super().step()\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.tanh_update","title":"tanh_update","text":"<pre><code>tanh_update(variation_coefficient)\n</code></pre> <p>Update function using the hyperbolic tangent (tanh) function.</p> <p>Parameters:</p> <ul> <li> <code>variation_coefficient</code>               (<code>float | NDArray</code>)           \u2013            <p>The variation coefficient.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | NDArray[floating]</code>           \u2013            <p>The updated value based on the tanh function.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def tanh_update(\n    self, variation_coefficient: float | NDArray\n) -&gt; float | NDArray[np.floating]:\n    \"\"\"\n    Update function using the hyperbolic tangent (tanh) function.\n\n    Parameters\n    ----------\n    variation_coefficient: float | NDArray\n        The variation coefficient.\n\n    Returns\n    -------\n    float | NDArray[np.floating]\n        The updated value based on the tanh function.\n    \"\"\"\n    return 1 - np.tanh(\n        variation_coefficient / self.reference_variance * math.atanh(0.5)\n    )\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.AdaptiveForceBias.update_delta","title":"update_delta","text":"<pre><code>update_delta()\n</code></pre> <p>Update the delta parameter based on the current variation coefficient. This method is called automatically during the step process.</p> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def update_delta(self) -&gt; None:\n    \"\"\"\n    Update the delta parameter based on the current variation coefficient. This method is called automatically during the step process.\n    \"\"\"\n    self.variation_coef = self.schemes[self.scheme](self.atoms)\n\n    self.delta = self.min_delta + (\n        self.max_delta - self.min_delta\n    ) * self.update_functions[self.update_function](self.variation_coef)\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias","title":"ForceBias","text":"<pre><code>ForceBias(atoms, delta, temperature=298.15, seed=None, **driver_kwargs)\n</code></pre> <p>               Bases: <code>Driver</code></p> <p>Force Bias Monte Carlo class to perform simulations as described in https://doi.org/10.1063/1.4902136.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atomic system being simulated.</p> </li> <li> <code>delta</code>               (<code>float</code>)           \u2013            <p>Delta parameter in \u00c5ngstrom which influence how much the atoms are moved.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>The temperature of the simulation in Kelvin, by default 298.15 K.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Seed for the random number generator, by default None. If None, a random seed is generated.</p> </li> <li> <code>**driver_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the parent classes. See <code>MonteCarlo</code> and <code>Driver</code> for more information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>gamma_max_value</code>               (<code>float</code>)           \u2013            <p>Maximum value for the gamma parameter, used to avoid overflow errors.</p> </li> <li> <code>delta</code>               (<code>float</code>)           \u2013            <p>Delta parameter in \u00c5ngstrom which influence how much the atoms are moved.</p> </li> <li> <code>temperature</code>               (<code>float</code>)           \u2013            <p>The temperature of the simulation in Kelvin.</p> </li> <li> <code>masses_scaling_power</code>               (<code>NDArray</code>)           \u2013            <p>Power to which the mass ratio is raised to scale the displacement.</p> </li> <li> <code>mass_scaling</code>               (<code>NDArray</code>)           \u2013            <p>Scaling factors for the atomic displacements based on masses.</p> </li> <li> <code>shaped_masses</code>               (<code>NDArray</code>)           \u2013            <p>Masses of the atoms shaped for vectorized calculations.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    delta: float,\n    temperature: float = 298.15,\n    seed: int | None = None,\n    **driver_kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the Force Bias Monte Carlo object.\"\"\"\n    self.delta = delta\n    self.temperature = temperature\n\n    self.__seed: Final = seed or PCG64().random_raw()\n    self._rng = RNG(PCG64(self.__seed))\n\n    super().__init__(atoms, **driver_kwargs)\n\n    self.update_masses(atoms.get_masses())\n    self.masses_scaling_power = 0.25\n\n    if not has_constraint(self.atoms, \"FixCom\"):\n        warn(\n            \"No `FixCom` constraint found, `ForceBias` simulations can lead to sustained drift of the center of mass.\",\n            UserWarning,\n            2,\n        )\n\n    self.gamma = 0.0\n\n    if self.default_logger:\n        self.default_logger.add_mc_fields(self)\n        self.default_logger.add_field(\n            \"Gamma/GammaMax\",\n            lambda: np.max(np.abs(self.gamma / self.gamma_max_value)),\n            str_format=\"{:&gt;16.2f}\",\n        )\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.masses_scaling_power","title":"masses_scaling_power  <code>property</code> <code>writable</code>","text":"<pre><code>masses_scaling_power\n</code></pre> <p>Get the power to which the mass ratio is raised to scale the displacement.</p> <p>Returns:</p> <ul> <li> <code>ShapedMasses | float</code>           \u2013            <p>The power value(s) for each atom and direction.</p> </li> </ul>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.calculate_gamma","title":"calculate_gamma","text":"<pre><code>calculate_gamma(forces)\n</code></pre> <p>Calculate the gamma parameter for the Monte Carlo step, along with the denominator for the trial probability.</p> <p>Parameters:</p> <ul> <li> <code>forces</code>               (<code>Forces</code>)           \u2013            <p>The forces acting on the atoms.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def calculate_gamma(self, forces: Forces) -&gt; None:\n    \"\"\"\n    Calculate the gamma parameter for the Monte Carlo step, along with the denominator for the trial probability.\n\n    Parameters\n    ----------\n    forces : Forces\n        The forces acting on the atoms.\n    \"\"\"\n    self.gamma = np.clip(\n        (forces * self.delta) / (2 * self.temperature * kB),\n        -self.gamma_max_value,\n        self.gamma_max_value,\n    )\n\n    self.denominator = np.exp(self.gamma) - np.exp(-self.gamma)\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.calculate_trial_probability","title":"calculate_trial_probability","text":"<pre><code>calculate_trial_probability()\n</code></pre> <p>Calculate the trial probability for the Monte Carlo step based on the force bias.</p> <p>Returns:</p> <ul> <li> <code>NDArray[floating]</code>           \u2013            <p>The trial probability for each atom and direction.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def calculate_trial_probability(self) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Calculate the trial probability for the Monte Carlo step based on the force bias.\n\n    Returns\n    -------\n    NDArray[np.floating]\n        The trial probability for each atom and direction.\n    \"\"\"\n    sign_zeta = np.sign(self.zeta)\n\n    probability_trial = np.exp(sign_zeta * self.gamma) - np.exp(\n        self.gamma * (2 * self.zeta - sign_zeta)\n    )\n    probability_trial *= sign_zeta\n\n    return np.divide(\n        probability_trial,\n        self.denominator,\n        out=np.ones_like(probability_trial),\n        where=self.denominator != 0,\n    )\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.get_zeta","title":"get_zeta","text":"<pre><code>get_zeta()\n</code></pre> <p>Get the zeta parameter for the current step.</p> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>The zeta parameter with values uniformly distributed between -1 and 1.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def get_zeta(self) -&gt; Displacements:\n    \"\"\"\n    Get the zeta parameter for the current step.\n\n    Returns\n    -------\n    Displacement\n        The zeta parameter with values uniformly distributed between -1 and 1.\n    \"\"\"\n    return self._rng.uniform(-1, 1, self.current_size)\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Perform one Force Bias Monte Carlo step.</p> <p>Returns:</p> <ul> <li> <code>Forces</code>           \u2013            <p>The forces acting on the atoms after the Monte Carlo step.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def step(self) -&gt; Forces:\n    \"\"\"\n    Perform one Force Bias Monte Carlo step.\n\n    Returns\n    -------\n    Forces\n        The forces acting on the atoms after the Monte Carlo step.\n    \"\"\"\n    forces = self.atoms.get_forces()\n    positions = self.atoms.get_positions()\n\n    self.current_size = (len(self.atoms), 3)\n\n    self.calculate_gamma(forces)\n\n    self.zeta = self.get_zeta()\n\n    probability_random = self._rng.random(self.current_size)\n    converged = self.calculate_trial_probability() &gt; probability_random\n\n    while not np.all(converged):\n        self.current_size = probability_random[~converged].shape\n        self.zeta[~converged] = self.get_zeta()\n\n        probability_random[~converged] = self._rng.random(self.current_size)\n\n        converged = self.calculate_trial_probability() &gt; probability_random\n\n    displacement = (\n        self.zeta\n        * self.delta\n        * np.power(\n            np.min(self.shaped_masses) / self.shaped_masses,\n            self.masses_scaling_power,\n        )\n    )\n\n    self.atoms.set_momenta(self.shaped_masses * displacement)\n    corrected_displacement = self.atoms.get_momenta() / self.shaped_masses\n\n    self.atoms.set_positions(positions + corrected_displacement)\n\n    return forces\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the ForceBias object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary containing the state of the ForceBias object, including the random number generator state,</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the ForceBias object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary containing the state of the ForceBias object, including the random number generator state,\n    \"\"\"\n    dictionary = super().to_dict()\n    dictionary[\"rng_state\"] = self._rng.bit_generator.state\n\n    dictionary.setdefault(\"kwargs\", {})\n    dictionary[\"kwargs\"] = {\n        \"seed\": self.__seed,\n        \"temperature\": self.temperature,\n        \"delta\": self.delta,\n    }\n\n    dictionary.setdefault(\"attributes\", {})\n    dictionary[\"attributes\"][\"masses_scaling_power\"] = self.masses_scaling_power\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/mc/fbmc.html#quansino.mc.fbmc.ForceBias.update_masses","title":"update_masses","text":"<pre><code>update_masses(masses=None)\n</code></pre> <p>Update the masses used for displacement scaling.</p> <p>Parameters:</p> <ul> <li> <code>masses</code>               (<code>ShapedMasses | Masses | None</code>, default:                   <code>None</code> )           \u2013            <p>The masses to use, by default None. If None, uses the masses from the atoms object.</p> </li> </ul> Source code in <code>quansino/mc/fbmc.py</code> <pre><code>def update_masses(self, masses: ShapedMasses | None = None) -&gt; None:\n    \"\"\"\n    Update the masses used for displacement scaling.\n\n    Parameters\n    ----------\n    masses : ShapedMasses | Masses | None, optional\n        The masses to use, by default None. If None, uses the masses from the atoms object.\n    \"\"\"\n    if masses is None:\n        masses = self.atoms.get_masses()\n\n    if masses.ndim == 1:\n        masses = np.broadcast_to(masses[:, np.newaxis], (len(self.atoms), 3))\n\n    self.shaped_masses = masses\n</code></pre>"},{"location":"reference/quansino/mc/gcmc.html","title":"gcmc","text":"<p>Module to perform Grand Canonical (\u03bcVT) Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical","title":"GrandCanonical","text":"<pre><code>GrandCanonical(atoms, exchange_atoms=None, temperature=298.15, chemical_potential=0.0, number_of_exchange_particles=0, default_displacement_move=None, default_exchange_move=None, **mc_kwargs)\n</code></pre> <p>               Bases: <code>Canonical[MoveType, CriteriaType]</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Grand Canonical (\u03bcVT) Monte Carlo object for performing simulations in the grand canonical ensemble. This class is a subclass of the <code>Canonical</code> class and provides additional functionality specific to grand canonical simulations. It uses the <code>ExchangeContext</code> context by default.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atomic configuration.</p> </li> <li> <code>exchange_atoms</code>               (<code>Atoms | None</code>, default:                   <code>None</code> )           \u2013            <p>The atoms that can be exchanged in the simulation, by default None.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>The temperature of the simulation in Kelvin, by default 298.15 K.</p> </li> <li> <code>chemical_potential</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The chemical potential of the system in eV, by default 0.0 eV.</p> </li> <li> <code>number_of_exchange_particles</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The number of particles that can be exchanged already in the <code>Atoms</code> object, by default 0.</p> </li> <li> <code>default_displacement_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default displacement move to perform in each cycle, by default None.</p> </li> <li> <code>default_exchange_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default exchange move to perform in each cycle, by default None.</p> </li> <li> <code>**mc_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the Monte Carlo simulation.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>accessible_volume</code>               (<code>float</code>)           \u2013            <p>The accessible volume for exchange particles in the simulation in \u00c5ngstroms cubed.</p> </li> <li> <code>exchange_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms that can be exchanged in the simulation.</p> </li> <li> <code>chemical_potential</code>               (<code>float</code>)           \u2013            <p>The chemical potential of the simulation in eV.</p> </li> <li> <code>number_of_exchange_particles</code>               (<code>int</code>)           \u2013            <p>The number of particles that can be exchanged in the simulation.</p> </li> </ul> Source code in <code>quansino/mc/gcmc.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    exchange_atoms: Atoms | None = None,\n    temperature: float = 298.15,\n    chemical_potential: float = 0.0,\n    number_of_exchange_particles: int = 0,\n    default_displacement_move: MoveType | None = None,\n    default_exchange_move: MoveType | None = None,\n    **mc_kwargs,\n) -&gt; None:\n    \"\"\"Initialize the `GrandCanonical` object.\"\"\"\n    super().__init__(\n        atoms,\n        temperature=temperature,\n        default_displacement_move=default_displacement_move,\n        **mc_kwargs,\n    )\n\n    if exchange_atoms is not None:\n        self.exchange_atoms = exchange_atoms\n\n    self.chemical_potential = chemical_potential\n    self.number_of_exchange_particles = number_of_exchange_particles\n\n    if default_exchange_move:\n        self.add_move(default_exchange_move, name=\"default_exchange_move\")\n\n    if self.default_logger:\n        self.default_logger.add_field(\"Natoms\", self.atoms.__len__, \"{:&gt;10d}\")\n\n    if isinstance(self.context, ExchangeContext):\n        self.context = cast(\"ExchangeContext\", self.context)\n    else:\n        warn(\n            \"The context is not a `ExchangeContext`. This may lead to unexpected behavior.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.accessible_volume","title":"accessible_volume  <code>property</code> <code>writable</code>","text":"<pre><code>accessible_volume\n</code></pre> <p>The accessible volume for exchange particles in the simulation.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The accessible volume in Angstroms cubed.</p> </li> </ul>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.chemical_potential","title":"chemical_potential  <code>property</code> <code>writable</code>","text":"<pre><code>chemical_potential\n</code></pre> <p>The chemical potential of the simulation.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The chemical potential in eV.</p> </li> </ul>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.exchange_atoms","title":"exchange_atoms  <code>property</code> <code>writable</code>","text":"<pre><code>exchange_atoms\n</code></pre> <p>The atoms that can be exchanged in the simulation.</p> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>The exchange atoms.</p> </li> </ul>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.number_of_exchange_particles","title":"number_of_exchange_particles  <code>property</code> <code>writable</code>","text":"<pre><code>number_of_exchange_particles\n</code></pre> <p>The number of particles that can be exchanged in the simulation.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of particles.</p> </li> </ul>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert the last move made to the context.</p> Source code in <code>quansino/mc/gcmc.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert the last move made to the context.\n    \"\"\"\n    self.context.revert_state()\n\n    try:\n        self.atoms.calc.atoms = self.atoms.copy()  # type: ignore[try-attr]\n        self.atoms.calc.results = self.last_results.copy()  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\"`Atoms` object does not have calculator attached.\", stacklevel=2)\n</code></pre>"},{"location":"reference/quansino/mc/gcmc.html#quansino.mc.gcmc.GrandCanonical.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Save the current state of the context and update move labels.</p> Source code in <code>quansino/mc/gcmc.py</code> <pre><code>def save_state(self) -&gt; None:\n    \"\"\"\n    Save the current state of the context and update move labels.\n    \"\"\"\n    for move_storage in self.moves.values():\n        move_storage.move.on_atoms_changed(\n            self.context._added_indices, self.context._deleted_indices\n        )\n\n    super().save_state()\n</code></pre>"},{"location":"reference/quansino/mc/isobaric.html","title":"isobaric","text":"<p>Module to perform isobaric (NPT) Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/isobaric.html#quansino.mc.isobaric.Isobaric","title":"Isobaric","text":"<pre><code>Isobaric(atoms, temperature, pressure=0.0, max_cycles=None, default_displacement_move=None, default_cell_move=None, **mc_kwargs)\n</code></pre> <p>               Bases: <code>Canonical[MoveType, CriteriaType]</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Isobaric (NPT) Monte Carlo simulation object for performing NPT simulations. This class is a subclass of the <code>Canonical</code> class and provides additional functionality specific to isobaric simulations. It uses the <code>DeformationContext</code> context by default.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on, will be acted upon in place.</p> </li> <li> <code>temperature</code>               (<code>float</code>)           \u2013            <p>The temperature of the simulation in Kelvin, by default 298.15 K.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The pressure of the simulation in eV/\u00c5^3, by default 0.0.</p> </li> <li> <code>default_displacement_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default displacement move to perform in each cycle, by default None.</p> </li> <li> <code>default_cell_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default cell move to perform in each cycle, by default None.</p> </li> <li> <code>**mc_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the parent classes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>pressure</code>               (<code>float</code>)           \u2013            <p>The pressure of the simulation in eV/\u00c5^3.</p> </li> <li> <code>default_criteria</code>               (<code>ClassVar</code>)           \u2013            <p>The default criteria used for the simulation, set to <code>CanonicalCriteria</code> for <code>DisplacementMove</code> and <code>IsobaricCriteria</code> for <code>CellMove</code>.</p> </li> <li> <code>default_context</code>               (<code>ClassVar</code>)           \u2013            <p>The default context used for the simulation, set to <code>DeformationContext</code>.</p> </li> </ul> Source code in <code>quansino/mc/isobaric.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    temperature: float,\n    pressure: float = 0.0,\n    max_cycles: int | None = None,\n    default_displacement_move: MoveType | None = None,\n    default_cell_move: MoveType | None = None,\n    **mc_kwargs,\n) -&gt; None:\n    \"\"\"Initialize the `Isobaric` object.\"\"\"\n    super().__init__(\n        atoms, temperature, max_cycles, default_displacement_move, **mc_kwargs\n    )\n\n    self.pressure = pressure\n\n    if default_cell_move:\n        self.add_move(default_cell_move, name=\"default_cell_move\")\n\n    self.set_default_probability()\n\n    if isinstance(self.context, DeformationContext):\n        self.context = cast(\"DeformationContext\", self.context)\n    else:\n        warn(\n            \"The context is not a `DeformationContext`. This may lead to unexpected behavior.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/isobaric.html#quansino.mc.isobaric.Isobaric.pressure","title":"pressure  <code>property</code> <code>writable</code>","text":"<pre><code>pressure\n</code></pre> <p>The pressure of the simulation.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The pressure in eV/\u00c5^3.</p> </li> </ul>"},{"location":"reference/quansino/mc/isobaric.html#quansino.mc.isobaric.Isobaric.revert_state","title":"revert_state","text":"<pre><code>revert_state()\n</code></pre> <p>Revert to the previously saved state and undo the last move. This method restores the cell state in addition to the state restored by the parent class.</p> Source code in <code>quansino/mc/isobaric.py</code> <pre><code>def revert_state(self) -&gt; None:\n    \"\"\"\n    Revert to the previously saved state and undo the last move. This method restores the cell state in addition to the state restored by the parent class.\n    \"\"\"\n    super().revert_state()\n\n    try:\n        self.atoms.calc.atoms.cell = self.atoms.cell.copy()  # type: ignore[try-attr]\n    except AttributeError:\n        warn(\"Atoms object does not have calculator attached.\", stacklevel=2)\n</code></pre>"},{"location":"reference/quansino/mc/isobaric.html#quansino.mc.isobaric.Isobaric.set_default_probability","title":"set_default_probability","text":"<pre><code>set_default_probability()\n</code></pre> <p>Set the default probability for the cell and displacement moves.</p> <p>The probability for cell moves is set to 1/(N+1) and the probability for displacement moves is set to 1/(1+1/N), where N is the number of atoms.</p> Source code in <code>quansino/mc/isobaric.py</code> <pre><code>def set_default_probability(self) -&gt; None:\n    \"\"\"\n    Set the default probability for the cell and displacement moves.\n\n    The probability for cell moves is set to 1/(N+1) and the probability for displacement moves is set to 1/(1+1/N), where N is the number of atoms.\n    \"\"\"\n    if cell_move := self.moves.get(\"default_cell_move\"):\n        cell_move.probability = 1 / (len(self.atoms) + 1)\n    if displacement_move := self.moves.get(\"default_displacement_move\"):\n        displacement_move.probability = 1 / (1 + 1 / len(self.atoms))\n</code></pre>"},{"location":"reference/quansino/mc/isobaric.html#quansino.mc.isobaric.Isobaric.validate_simulation","title":"validate_simulation","text":"<pre><code>validate_simulation()\n</code></pre> <p>This method also ensures that the cell is saved in the context.</p> Source code in <code>quansino/mc/isobaric.py</code> <pre><code>def validate_simulation(self) -&gt; None:\n    \"\"\"\n    This method also ensures that the cell is saved in the context.\n    \"\"\"\n    self.context.last_cell = self.atoms.get_cell()\n\n    super().validate_simulation()\n</code></pre>"},{"location":"reference/quansino/mc/isotension.html","title":"isotension","text":"<p>Module to perform isobaric (NPT) Monte Carlo simulations.</p>"},{"location":"reference/quansino/mc/isotension.html#quansino.mc.isotension.Isotension","title":"Isotension","text":"<pre><code>Isotension(atoms, temperature, pressure=0.0, external_stress=None, max_cycles=None, default_displacement_move=None, default_cell_move=None, **mc_kwargs)\n</code></pre> <p>               Bases: <code>Isobaric[MoveType, CriteriaType]</code>, <code>Generic[MoveType, CriteriaType]</code></p> <p>Isobaric (NPT) Monte Carlo simulation object for performing NPT simulations. This class is a subclass of the <code>Canonical</code> class and provides additional functionality specific to isobaric simulations. It uses the <code>DeformationContext</code> context by default.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to perform the simulation on, will be acted upon in place.</p> </li> <li> <code>temperature</code>               (<code>float</code>)           \u2013            <p>The temperature of the simulation in Kelvin, by default 298.15 K.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The pressure of the simulation in eV/\u00c5^3, by default 0.0.</p> </li> <li> <code>default_displacement_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default displacement move to perform in each cycle, by default None.</p> </li> <li> <code>default_cell_move</code>               (<code>MoveType | None</code>, default:                   <code>None</code> )           \u2013            <p>The default cell move to perform in each cycle, by default None.</p> </li> <li> <code>**mc_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the parent classes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>pressure</code>               (<code>float</code>)           \u2013            <p>The pressure of the simulation in eV/\u00c5^3.</p> </li> <li> <code>default_criteria</code>               (<code>ClassVar</code>)           \u2013            <p>The default criteria used for the simulation, set to <code>CanonicalCriteria</code> for <code>DisplacementMove</code> and <code>IsobaricCriteria</code> for <code>CellMove</code>.</p> </li> <li> <code>default_context</code>               (<code>ClassVar</code>)           \u2013            <p>The default context used for the simulation, set to <code>DeformationContext</code>.</p> </li> </ul> Source code in <code>quansino/mc/isotension.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    temperature: float,\n    pressure: float = 0.0,\n    external_stress: Stress | None = None,\n    max_cycles: int | None = None,\n    default_displacement_move: MoveType | None = None,\n    default_cell_move: MoveType | None = None,\n    **mc_kwargs,\n) -&gt; None:\n    \"\"\"Initialize the `Isotension` object.\"\"\"\n    super().__init__(\n        atoms,\n        temperature,\n        pressure,\n        max_cycles,\n        default_displacement_move,\n        **mc_kwargs,\n    )\n\n    self.pressure = pressure\n    self.external_stress = (\n        np.zeros((3, 3)) if external_stress is None else external_stress\n    )\n\n    if default_cell_move:\n        self.add_move(default_cell_move, name=\"default_cell_move\")\n\n        # if self.default_logger:\n        # self.default_logger.add_field()\n\n    self.set_default_probability()\n\n    if isinstance(self.context, DeformationContext):\n        self.context = cast(\"DeformationContext\", self.context)\n    else:\n        warn(\n            \"The context is not a `DeformationContext`. This may lead to unexpected behavior.\",\n            UserWarning,\n            2,\n        )\n</code></pre>"},{"location":"reference/quansino/mc/isotension.html#quansino.mc.isotension.Isotension.external_stress","title":"external_stress  <code>property</code> <code>writable</code>","text":"<pre><code>external_stress\n</code></pre> <p>The external stress tensor applied to the system.</p> <p>Returns:</p> <ul> <li> <code>Stress</code>           \u2013            <p>The external stress tensor in eV/\u00c5^3.</p> </li> </ul>"},{"location":"reference/quansino/moves/cell.html","title":"cell","text":"<p>Module for cell moves.</p>"},{"location":"reference/quansino/moves/cell.html#quansino.moves.cell.CellMove","title":"CellMove","text":"<pre><code>CellMove(operation=None, scale_atoms=True, apply_constraints=True)\n</code></pre> <p>               Bases: <code>BaseMove[OperationType, ContextType]</code>, <code>Generic[OperationType, ContextType]</code></p> <p>Class for cell moves that change the size and shape of the unit cell.</p> <p>Parameters:</p> <ul> <li> <code>operation</code>               (<code>OperationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The operation to perform in the move, by default None. If None, it defaults to <code>IsotropicDeformation</code>.</p> </li> <li> <code>scale_atoms</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to scale the atom positions when the cell changes, by default True.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints to the move, by default True.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>scale_atoms</code>               (<code>bool</code>)           \u2013            <p>Whether to scale the atom positions when the cell changes.</p> </li> <li> <code>composite_move_type</code>               (<code>CompositeMove[CellMove[OperationType, ContextType]]</code>)           \u2013            <p>The type of composite move returned by this move when adding it with another <code>CellMove</code>.</p> </li> </ul> Source code in <code>quansino/moves/cell.py</code> <pre><code>def __init__(\n    self,\n    operation: OperationType | None = None,\n    scale_atoms: bool = True,\n    apply_constraints: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the `CellMove` object.\"\"\"\n    super().__init__(operation, apply_constraints)\n\n    self.scale_atoms = scale_atoms\n\n    self.composite_move_type = CompositeMove[CellMove[OperationType, ContextType]]\n</code></pre>"},{"location":"reference/quansino/moves/cell.html#quansino.moves.cell.CellMove.default_operation","title":"default_operation  <code>property</code>","text":"<pre><code>default_operation\n</code></pre> <p>Get the default operation for the move.</p> <p>Returns:</p> <ul> <li> <code>Operation</code>           \u2013            <p>The default operation for the move.</p> </li> </ul>"},{"location":"reference/quansino/moves/cell.html#quansino.moves.cell.CellMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the cell move.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context for the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/cell.py</code> <pre><code>def __call__(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Perform the cell move.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context for the move.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    return self.attempt_deformation(context)\n</code></pre>"},{"location":"reference/quansino/moves/cell.html#quansino.moves.cell.CellMove.attempt_deformation","title":"attempt_deformation","text":"<pre><code>attempt_deformation(context)\n</code></pre> <p>Attempt to move the atoms using the provided operation and check. The move is attempted <code>max_attempts</code> number of times. If the move is successful, return True, otherwise, return False.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context for the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/cell.py</code> <pre><code>def attempt_deformation(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Attempt to move the atoms using the provided operation and check. The move is attempted `max_attempts` number of times. If the move is successful, return True, otherwise, return False.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context for the move.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    atoms = context.atoms\n    old_cell = atoms.cell.copy()\n    old_positions = atoms.positions.copy()\n\n    for _ in range(self.max_attempts):\n        deformation_gradient = self.operation.calculate(context)\n\n        atoms.set_cell(\n            deformation_gradient @ old_cell,\n            scale_atoms=self.scale_atoms,\n            apply_constraint=self.apply_constraints,\n        )\n\n        if self.check_move(context):\n            return True\n\n        atoms.cell = old_cell\n\n        if self.scale_atoms:\n            atoms.positions = old_positions\n\n    return False\n</code></pre>"},{"location":"reference/quansino/moves/composite.html","title":"composite","text":"<p>Module for Base Move class</p>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove","title":"CompositeMove","text":"<pre><code>CompositeMove(moves)\n</code></pre> <p>               Bases: <code>Generic[MoveType]</code></p> <p>Class to perform a composite move operation. This class is returned when adding or multiplying <code>Move</code> objects together.</p> <p>Parameters:</p> <ul> <li> <code>moves</code>               (<code>list[MoveType]</code>)           \u2013            <p>The moves to perform in the composite move.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>moves</code>               (<code>list[MoveType]</code>)           \u2013            <p>The moves to perform in the composite move.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __init__(self, moves: list[MoveType]) -&gt; None:\n    \"\"\"Initialize the `CompositeMove` object.\"\"\"\n    self.moves = moves\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__add__","title":"__add__","text":"<pre><code>__add__(other: CompositeMove[MoveType]) -&gt; CompositeMove[MoveType]\n</code></pre><pre><code>__add__(other: MoveType) -&gt; CompositeMove[MoveType]\n</code></pre><pre><code>__add__(other: CompositeMove) -&gt; CompositeMove[Move]\n</code></pre><pre><code>__add__(other: Move) -&gt; CompositeMove[Move]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Add two moves together to create a <code>CompositeMove</code> object.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>CompositeMove | Move</code>)           \u2013            <p>The other move to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeMove</code>           \u2013            <p>The composite move.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Add two moves together to create a `CompositeMove` object.\n\n    Parameters\n    ----------\n    other : CompositeMove | Move\n        The other move to add.\n\n    Returns\n    -------\n    CompositeMove\n        The composite move.\n    \"\"\"\n    from quansino.moves.core import BaseMove  # noqa: PLC0415\n\n    if isinstance(other, CompositeMove):\n        if type(self) is type(other):\n            return type(self)(self.moves + other.moves)\n\n        return CompositeMove(self.moves + other.moves)\n    elif isinstance(other, BaseMove):\n        if type(self) is other.composite_move_type:\n            return other.composite_move_type([*self.moves, other])\n        else:\n            return CompositeMove([*self.moves, other])\n\n    raise TypeError(\n        f\"Cannot add {self.__class__.__name__} to {other.__class__.__name__}\"\n    )\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__call__","title":"__call__","text":"<pre><code>__call__(context, *_args, **_kwargs)\n</code></pre> <p>Perform the composite move by executing all constituent moves.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context in which the move is performed, containing information about the system state.</p> </li> <li> <code>*_args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Additional positional arguments, not used in this method.</p> </li> <li> <code>**_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments, not used in this method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether any of the constituent moves was successful.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __call__(self, context: Context, *_args: Any, **_kwargs: Any) -&gt; bool:\n    \"\"\"\n    Perform the composite move by executing all constituent moves.\n\n    Parameters\n    ----------\n    context : Context\n        The context in which the move is performed, containing information about the system state.\n    *_args : Any\n        Additional positional arguments, not used in this method.\n    **_kwargs : Any\n        Additional keyword arguments, not used in this method.\n\n    Returns\n    -------\n    bool\n        Whether any of the constituent moves was successful.\n    \"\"\"\n    return any([move(context) for move in self.moves])  # noqa: C419\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Get the move at the specified index.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>The index of the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MoveType</code>           \u2013            <p>The move at the specified index.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __getitem__(self, index: int) -&gt; MoveType:\n    \"\"\"\n    Get the move at the specified index.\n\n    Parameters\n    ----------\n    index : int\n        The index of the move.\n\n    Returns\n    -------\n    MoveType\n        The move at the specified index.\n    \"\"\"\n    return self.moves[index]\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over the moves in the composite move.</p> <p>Returns:</p> <ul> <li> <code>Iterator[MoveType]</code>           \u2013            <p>An iterator over the moves in the composite move.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __iter__(self) -&gt; Iterator[MoveType]:\n    \"\"\"\n    Iterate over the moves in the composite move.\n\n    Returns\n    -------\n    Iterator[MoveType]\n        An iterator over the moves in the composite move.\n    \"\"\"\n    return iter(self.moves)\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Get the number of moves in the composite move.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of moves in the composite move.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of moves in the composite move.\n\n    Returns\n    -------\n    int\n        The number of moves in the composite move.\n    \"\"\"\n    return len(self.moves)\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.__mul__","title":"__mul__","text":"<pre><code>__mul__(n)\n</code></pre> <p>Multiply the move by an integer to create a <code>CompositeMove</code> with repeated moves.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of times to repeat the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeMove</code>           \u2013            <p>The composite move with repeated moves.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def __mul__(self, n: int) -&gt; CompositeMove[MoveType]:\n    \"\"\"\n    Multiply the move by an integer to create a `CompositeMove` with repeated moves.\n\n    Parameters\n    ----------\n    n : int\n        The number of times to repeat the move.\n\n    Returns\n    -------\n    CompositeMove\n        The composite move with repeated moves.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\n            f\"The number of times the move is repeated must be a positive, non-zero integer. Got {type(n)}.\"\n        )\n    if n &lt; 1:\n        raise ValueError(\n            \"The number of times the move is repeated must be a positive, non-zero integer.\"\n        )\n\n    return type(self)(self.moves * n)\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create a <code>CompositeMove</code> from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the composite move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>CompositeMove</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create a `CompositeMove` from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the composite move.\n\n    Returns\n    -------\n    Self\n        The `CompositeMove` object created from the dictionary.\n    \"\"\"\n    moves = []\n    kwargs = deepcopy(data.get(\"kwargs\", {}))\n\n    if \"moves\" in kwargs:\n        for move_data in kwargs[\"moves\"]:\n            move_class: type[Move] = get_typed_class(move_data[\"name\"], Move)\n            move = move_class.from_dict(move_data)\n            moves.append(move)\n\n    kwargs[\"moves\"] = moves\n\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.on_atoms_changed","title":"on_atoms_changed","text":"<pre><code>on_atoms_changed(added_indices, removed_indices)\n</code></pre> <p>Update the move by resetting the labels and updating the operation.</p> <p>Parameters:</p> <ul> <li> <code>added_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms to add.</p> </li> <li> <code>removed_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms to remove.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def on_atoms_changed(\n    self, added_indices: IntegerArray, removed_indices: IntegerArray\n) -&gt; None:\n    \"\"\"\n    Update the move by resetting the labels and updating the operation.\n\n    Parameters\n    ----------\n    added_indices : IntegerArray\n        The indices of the atoms to add.\n    removed_indices : IntegerArray\n        The indices of the atoms to remove.\n    \"\"\"\n    for move in self.moves:\n        move.on_atoms_changed(added_indices, removed_indices)\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.on_cell_changed","title":"on_cell_changed","text":"<pre><code>on_cell_changed(new_cell)\n</code></pre> <p>Update the move when the cell changes.</p> <p>Parameters:</p> <ul> <li> <code>new_cell</code>               (<code>Cell</code>)           \u2013            <p>The new cell.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def on_cell_changed(self, new_cell: Cell) -&gt; None:\n    \"\"\"\n    Update the move when the cell changes.\n\n    Parameters\n    ----------\n    new_cell : Cell\n        The new cell.\n    \"\"\"\n    for move in self.moves:\n        move.on_cell_changed(new_cell)\n</code></pre>"},{"location":"reference/quansino/moves/composite.html#quansino.moves.composite.CompositeMove.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>CompositeMove</code> object to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>CompositeMove</code> object.</p> </li> </ul> Source code in <code>quansino/moves/composite.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `CompositeMove` object to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `CompositeMove` object.\n    \"\"\"\n    return {\n        \"name\": self.__class__.__name__,\n        \"kwargs\": {\"moves\": [move.to_dict() for move in self.moves]},\n    }\n</code></pre>"},{"location":"reference/quansino/moves/core.html","title":"core","text":"<p>Module for Base Move class</p>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove","title":"BaseMove","text":"<pre><code>BaseMove(operation, apply_constraints=True)\n</code></pre> <p>               Bases: <code>Generic[OperationType, ContextType]</code></p> <p>Base class to build Monte Carlo moves. This is a generic base class for all Monte Carlo moves, parameterized by the operation type and context type it works with.</p> <p>Parameters:</p> <ul> <li> <code>operation</code>               (<code>OperationType | None</code>)           \u2013            <p>The operation to perform, by default None. If None, the default operation for the move will be used.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints to the move, by default True.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>max_attempts</code>               (<code>int</code>)           \u2013            <p>The maximum number of attempts to make for a successful move, default is 10000.</p> </li> <li> <code>operation</code>               (<code>OperationType</code>)           \u2013            <p>The operation to perform in the move.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>)           \u2013            <p>Whether to apply constraints to the move.</p> </li> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The simulation context attached to this move.</p> </li> <li> <code>check_move</code>               (<code>Callable[..., bool]</code>)           \u2013            <p>A callable that returns True if the move should proceed, False otherwise.</p> </li> <li> <code>composite_move_type</code>               (<code>type[CompositeMove]</code>)           \u2013            <p>The type of composite move that this move can be combined into.</p> </li> </ul> Notes <p>This class is a base class for all Monte Carlo moves, and should not be used directly. The call method should be implemented in the subclass, performing the actual move and returning a boolean indicating whether the move was accepted. Classes inheriting from <code>BaseMove</code> should implement the <code>default_operation</code> property to provide a default operation when None is specified during initialization.</p> Source code in <code>quansino/moves/core.py</code> <pre><code>def __init__(\n    self, operation: OperationType | None, apply_constraints: bool = True\n) -&gt; None:\n    \"\"\"Initialize the `BaseMove` object.\"\"\"\n    self.operation: OperationType = operation or self.default_operation\n    self.apply_constraints: bool = apply_constraints\n\n    self.composite_move_type: type[CompositeMove] = CompositeMove[\n        BaseMove[OperationType, ContextType]\n    ]\n\n    self.max_attempts = 10000\n    self.check_move: Callable[..., bool] = lambda *_args, **_kwargs: True\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.default_operation","title":"default_operation  <code>property</code>","text":"<pre><code>default_operation\n</code></pre> <p>Get the default operation for the move.</p> <p>Returns:</p> <ul> <li> <code>OperationType</code>           \u2013            <p>The default operation for the move.</p> </li> </ul>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.__add__","title":"__add__","text":"<pre><code>__add__(other: MoveType) -&gt; CompositeMove[MoveType]\n</code></pre><pre><code>__add__(other: CompositeMove[MoveType]) -&gt; CompositeMove[MoveType]\n</code></pre><pre><code>__add__(other: CompositeMove[Move]) -&gt; CompositeMove[Move]\n</code></pre><pre><code>__add__(other: Move) -&gt; CompositeMove[Move]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Add two moves together to create a <code>CompositeMove</code>.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Move | CompositeMove</code>)           \u2013            <p>The other displacement move to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeMove</code>           \u2013            <p>The composite move.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Add two moves together to create a `CompositeMove`.\n\n    Parameters\n    ----------\n    other : Move | CompositeMove\n        The other displacement move to add.\n\n    Returns\n    -------\n    CompositeMove\n        The composite move.\n    \"\"\"\n    if isinstance(other, CompositeMove):\n        if type(self.composite_move_type) is type(other):\n            return self.composite_move_type([self, *other.moves])\n        else:\n            return CompositeMove([self, *other.moves])\n    elif isinstance(other, BaseMove):\n        if self.composite_move_type is other.composite_move_type:\n            return other.composite_move_type([self, other])\n        else:\n            return CompositeMove([self, other])\n\n    raise TypeError(\n        f\"Cannot add {self.__class__.__name__} to {other.__class__.__name__}\"\n    )\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Call the move. This method should be implemented in the subclass, and should return a boolean indicating whether the move was accepted.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was accepted.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def __call__(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Call the move. This method should be implemented in the subclass, and should return a boolean indicating whether the move was accepted.\n\n    Returns\n    -------\n    bool\n        Whether the move was accepted.\n    \"\"\"\n    raise NotImplementedError(\n        f\"{self.__class__.__name__} does not implement the __call__ method.\"\n    )\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.__copy__","title":"__copy__","text":"<pre><code>__copy__()\n</code></pre> <p>Create a shallow copy of the move.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The shallow copy of the move.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def __copy__(self) -&gt; BaseMove:\n    \"\"\"\n    Create a shallow copy of the move.\n\n    Returns\n    -------\n    Self\n        The shallow copy of the move.\n    \"\"\"\n    return self.from_dict(self.to_dict())\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.__mul__","title":"__mul__","text":"<pre><code>__mul__(n)\n</code></pre> <p>Multiply the move by an integer to create a <code>CompositeMove</code> with repeated moves.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of times to repeat the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeMove</code>           \u2013            <p>The composite move.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def __mul__(self, n: int) -&gt; CompositeMove[BaseMove]:\n    \"\"\"\n    Multiply the move by an integer to create a `CompositeMove` with repeated moves.\n\n    Parameters\n    ----------\n    n : int\n        The number of times to repeat the move.\n\n    Returns\n    -------\n    CompositeMove\n        The composite move.\n    \"\"\"\n    if n &lt; 1 or not isinstance(n, int):\n        raise ValueError(\n            \"The number of times the move is repeated must be a positive, non-zero integer.\"\n        )\n\n    return self.composite_move_type([self] * n)\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create a <code>BaseMove</code> object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the <code>BaseMove</code> object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>BaseMove</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create a `BaseMove` object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the `BaseMove` object.\n\n    Returns\n    -------\n    Self\n        The `BaseMove` object created from the dictionary.\n    \"\"\"\n    kwargs = deepcopy(data.get(\"kwargs\", {}))\n\n    if \"operation\" in kwargs:\n        operation_data = kwargs[\"operation\"]\n\n        operation_class: type[Operation] = get_typed_class(\n            operation_data[\"name\"], Operation\n        )\n\n        kwargs[\"operation\"] = operation_class.from_dict(operation_data)\n\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.on_atoms_changed","title":"on_atoms_changed","text":"<pre><code>on_atoms_changed(added_indices, removed_indices)\n</code></pre> <p>Update the move when atoms are added or removed.</p> <p>Parameters:</p> <ul> <li> <code>added_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms that were added.</p> </li> <li> <code>removed_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms that were removed.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def on_atoms_changed(\n    self, added_indices: IntegerArray, removed_indices: IntegerArray\n) -&gt; None:\n    \"\"\"\n    Update the move when atoms are added or removed.\n\n    Parameters\n    ----------\n    added_indices : IntegerArray\n        The indices of the atoms that were added.\n    removed_indices : IntegerArray\n        The indices of the atoms that were removed.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.on_cell_changed","title":"on_cell_changed","text":"<pre><code>on_cell_changed(new_cell)\n</code></pre> <p>Update the move when the cell changes.</p> <p>Parameters:</p> <ul> <li> <code>new_cell</code>               (<code>Cell</code>)           \u2013            <p>The new cell.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def on_cell_changed(self, new_cell: Cell) -&gt; None:\n    \"\"\"\n    Update the move when the cell changes.\n\n    Parameters\n    ----------\n    new_cell : Cell\n        The new cell.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/moves/core.html#quansino.moves.core.BaseMove.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>BaseMove</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>BaseMove</code> object.</p> </li> </ul> Source code in <code>quansino/moves/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `BaseMove` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `BaseMove` object.\n    \"\"\"\n    return {\n        \"name\": self.__class__.__name__,\n        \"kwargs\": {\n            \"operation\": self.operation.to_dict(),\n            \"apply_constraints\": self.apply_constraints,\n        },\n    }\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html","title":"displacement","text":"<p>Module for displacement moves.</p>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.CompositeDisplacementMove","title":"CompositeDisplacementMove","text":"<pre><code>CompositeDisplacementMove(moves)\n</code></pre> <p>               Bases: <code>CompositeMove[DisplacementMove]</code></p> <p>Class to perform a composite displacement operation on atoms. This class is returned when adding or multiplying <code>DisplacementMove</code> objects together.</p> <p>Parameters:</p> <ul> <li> <code>moves</code>               (<code>list[DisplacementMove]</code>)           \u2013            <p>The moves to perform in the composite move.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>moves</code>               (<code>list[DisplacementMove]</code>)           \u2013            <p>The moves to perform in the composite move.</p> </li> <li> <code>displaced_labels</code>               (<code>list[int | None]</code>)           \u2013            <p>The labels of the atoms that were displaced in the last move.</p> </li> <li> <code>number_of_moved_particles</code>               (<code>int</code>)           \u2013            <p>The number of particles that were moved in the last move.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def __init__(self, moves: list[DisplacementMove]) -&gt; None:\n    super().__init__(moves)\n\n    self.displaced_labels: list[int | None] = []\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.CompositeDisplacementMove.number_of_moved_particles","title":"number_of_moved_particles  <code>property</code>","text":"<pre><code>number_of_moved_particles\n</code></pre> <p>The number of particles that were moved in the last move.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of particles that were moved.</p> </li> </ul>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.CompositeDisplacementMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the composite displacement move. The following steps are performed:</p> <ol> <li>Reset the displaced_labels list to prepare for the new move.</li> <li>For each move in the composite, find available candidates that haven't been displaced yet in this composite move.</li> <li>If no candidates are available for a move, register a failure for that move and continue.</li> <li>Select a random candidate from the available labels and attempt the displacement.</li> <li>Register success or failure for each individual move.</li> <li>Return True if at least one particle was moved, False otherwise.</li> </ol> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The context for the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether at least one move in the composite was successful.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def __call__(self, context: DisplacementContext) -&gt; bool:\n    \"\"\"\n    Perform the composite displacement move. The following steps are performed:\n\n    1. Reset the displaced_labels list to prepare for the new move.\n    2. For each move in the composite, find available candidates that haven't been displaced yet in this composite move.\n    3. If no candidates are available for a move, register a failure for that move and continue.\n    4. Select a random candidate from the available labels and attempt the displacement.\n    5. Register success or failure for each individual move.\n    6. Return True if at least one particle was moved, False otherwise.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The context for the move.\n\n    Returns\n    -------\n    bool\n        Whether at least one move in the composite was successful.\n    \"\"\"\n    self.reset()\n\n    for move in self.moves:\n        filtered_displaced_labels = [\n            atom for atom in self.displaced_labels if atom is not None\n        ]\n        available_candidates = np.setdiff1d(\n            move.unique_labels, filtered_displaced_labels, assume_unique=True\n        )\n        if len(available_candidates) == 0:\n            self.register_failure()\n            continue\n\n        move.to_displace_labels = context.rng.choice(available_candidates)\n\n        if move(context):\n            self.register_success(move)\n        else:\n            self.register_failure()\n\n    return self.number_of_moved_particles &gt; 0\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.CompositeDisplacementMove.register_failure","title":"register_failure","text":"<pre><code>register_failure()\n</code></pre> <p>Register a failed move, reverting any changes made.</p> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def register_failure(self) -&gt; None:\n    \"\"\"Register a failed move, reverting any changes made.\"\"\"\n    self.displaced_labels.append(None)\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.CompositeDisplacementMove.register_success","title":"register_success","text":"<pre><code>register_success(move)\n</code></pre> <p>Register a successful move, saving the current state.</p> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def register_success(self, move: DisplacementMove) -&gt; None:\n    \"\"\"Register a successful move, saving the current state.\"\"\"\n    self.displaced_labels.append(move.displaced_labels)\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove","title":"DisplacementMove","text":"<pre><code>DisplacementMove(labels, operation=None, apply_constraints=True)\n</code></pre> <p>               Bases: <code>BaseMove[OperationType, ContextType]</code>, <code>Generic[OperationType, ContextType]</code></p> <p>Class for displacement moves that displaces one atom or a group of atoms. The class will use an <code>Operation</code>. The class uses the <code>labels</code> attribute to determine which atoms can be displaced, if none, the move fails. If multiple atoms share the same label, they are considered to be part of the same group (molecule) and will be displaced together in a consistent manner.</p> <p>Move that displaces multiple labels at once can be created by adding multiple <code>DisplacementMove</code> objects together. Similarly, a move can be multiplied by an integer to move multiple labels at once in the same manner. In this case a <code>CompositeDisplacementMove</code> object is returned, which can be used as a normal DisplacementMove object.</p> <p>The move only modifies the <code>moving_indices</code> attribute of the context object, which might be needed for some operations (Rotation, for example).</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The labels of the atoms to displace. Atoms with negative labels are not displaced.</p> </li> <li> <code>operation</code>               (<code>Operation</code>, default:                   <code>None</code> )           \u2013            <p>The operation to perform in the move, by default None.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints to the move, by default True.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>is_updatable</code>               (<code>Literal[True]</code>)           \u2013            <p>Whether the move can be updated when atoms are added or removed.</p> </li> <li> <code>to_displace_labels</code>               (<code>int | None</code>)           \u2013            <p>The label of the atoms to displace. If None, the move will select the atoms to displace itself. Reset to None after move.</p> </li> <li> <code>displaced_labels</code>               (<code>int | None</code>)           \u2013            <p>The label of the atoms that were displaced in the last move. Reset to None after move.</p> </li> <li> <code>default_label</code>               (<code>int | None</code>)           \u2013            <p>The default label when adding new atoms. If None, labels for new atoms will be selected automatically.</p> </li> <li> <code>labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The labels of the atoms in the simulation.</p> </li> <li> <code>unique_labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The unique labels in the simulation (excluding negative labels).</p> </li> </ul> Important <p>At object creation, <code>labels</code> must have the same length as the number of atoms in the simulation.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The labels of the atoms to displace. Atoms with negative labels are not displaced.</p> </li> <li> <code>operation</code>               (<code>Operation</code>, default:                   <code>None</code> )           \u2013            <p>The operation to perform in the move, by default None.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints to the move, by default True.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def __init__(\n    self,\n    labels: IntegerArray,\n    operation: OperationType | None = None,\n    apply_constraints: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the DisplacementMove object.\n\n    Parameters\n    ----------\n    labels : IntegerArray\n        The labels of the atoms to displace. Atoms with negative labels are not displaced.\n    operation : Operation, optional\n        The operation to perform in the move, by default None.\n    apply_constraints : bool, optional\n        Whether to apply constraints to the move, by default True.\n    \"\"\"\n    self.to_displace_labels: int | None = None\n    self.displaced_labels: int | None = None\n\n    self.default_label: int | None = None\n    self.set_labels(labels)\n\n    super().__init__(operation, apply_constraints)\n\n    self.composite_move_type = CompositeDisplacementMove\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.default_operation","title":"default_operation  <code>property</code>","text":"<pre><code>default_operation\n</code></pre> <p>Get the default operation for the move.</p> <p>Returns:</p> <ul> <li> <code>OperationType</code>           \u2013            <p>The default operation for the move.</p> </li> </ul>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the displacement move. The following steps are performed:</p> <ol> <li>Check if the atoms to displace are manually set. If not, select a random label from the available labels, if no labels are available, the move fails.</li> <li>Find the indices of the atoms to displace and attempt to move them using <code>attempt_displacement</code>. If the move is successful, register a success and return True. Otherwise, register a failure and return False.</li> </ol> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context for the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def __call__(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Perform the displacement move. The following steps are performed:\n\n    1. Check if the atoms to displace are manually set. If not, select a random label from the available labels, if no labels are available, the move fails.\n    2. Find the indices of the atoms to displace and attempt to move them using `attempt_displacement`. If the move is successful, register a success and return True. Otherwise, register a failure and return False.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context for the move.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    if self.to_displace_labels is None:\n        if len(self.unique_labels) == 0:\n            return self.register_failure()\n\n        self.to_displace_labels = context.rng.choice(self.unique_labels)\n\n    (context._moving_indices,) = np.where(self.labels == self.to_displace_labels)\n\n    if self.attempt_displacement(context):\n        return self.register_success()\n    else:\n        return self.register_failure()\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.attempt_displacement","title":"attempt_displacement","text":"<pre><code>attempt_displacement(context)\n</code></pre> <p>Attempt to move the atoms using the provided operation and check. The move is attempted <code>max_attempts</code> number of times. If the move is successful, return True, otherwise, return False.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context for the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def attempt_displacement(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Attempt to move the atoms using the provided operation and check. The move is attempted `max_attempts` number of times. If the move is successful, return True, otherwise, return False.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context for the move.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    atoms = context.atoms\n    old_positions = atoms.get_positions()\n\n    for _ in range(self.max_attempts):\n        translation = np.full((len(atoms), 3), 0.0)\n        translation[context._moving_indices] = self.operation.calculate(context)\n\n        atoms.set_positions(\n            atoms.positions + translation, apply_constraint=self.apply_constraints\n        )\n\n        if self.check_move(context):\n            return True\n\n        atoms.positions = old_positions\n\n    return False\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.on_atoms_changed","title":"on_atoms_changed","text":"<pre><code>on_atoms_changed(added_indices, removed_indices)\n</code></pre> <p>Update the move by resetting the labels and updating the operation.</p> <p>Parameters:</p> <ul> <li> <code>added_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms to add.</p> </li> <li> <code>removed_indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices of the atoms to remove.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the length of the labels is not equal to the number of atoms.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def on_atoms_changed(\n    self, added_indices: IntegerArray, removed_indices: IntegerArray\n) -&gt; None:\n    \"\"\"\n    Update the move by resetting the labels and updating the operation.\n\n    Parameters\n    ----------\n    added_indices : IntegerArray\n        The indices of the atoms to add.\n    removed_indices : IntegerArray\n        The indices of the atoms to remove.\n\n    Raises\n    ------\n    ValueError\n        If the length of the labels is not equal to the number of atoms.\n    \"\"\"\n    if len(added_indices):\n        label: int = self.default_label or (\n            np.max(self.unique_labels) + 1 if len(self.unique_labels) else 0\n        )\n        self.set_labels(\n            np.hstack((self.labels, np.full(len(added_indices), label)))\n        )\n\n    if len(removed_indices):\n        self.set_labels(np.delete(self.labels, removed_indices))\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.register_failure","title":"register_failure","text":"<pre><code>register_failure()\n</code></pre> <p>Register a failed move, reverting any changes made.</p> <p>Returns:</p> <ul> <li> <code>Literal[False]</code>           \u2013            <p>Always returns False.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def register_failure(self) -&gt; Literal[False]:\n    \"\"\"\n    Register a failed move, reverting any changes made.\n\n    Returns\n    -------\n    Literal[False]\n        Always returns False.\n    \"\"\"\n    self.to_displace_labels = None\n    self.displaced_labels = None\n\n    return False\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.register_success","title":"register_success","text":"<pre><code>register_success()\n</code></pre> <p>Register a successful move, saving the current state.</p> <p>Returns:</p> <ul> <li> <code>Literal[True]</code>           \u2013            <p>Always returns True.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def register_success(self) -&gt; Literal[True]:\n    \"\"\"\n    Register a successful move, saving the current state.\n\n    Returns\n    -------\n    Literal[True]\n        Always returns True.\n    \"\"\"\n    self.displaced_labels = self.to_displace_labels\n    self.to_displace_labels = None\n\n    return True\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.set_labels","title":"set_labels","text":"<pre><code>set_labels(new_labels)\n</code></pre> <p>Set the labels of the atoms to displace and update the unique labels. This function should always be used to set the labels.</p> <p>Parameters:</p> <ul> <li> <code>new_labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The new labels of the atoms to displace.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def set_labels(self, new_labels: IntegerArray) -&gt; None:\n    \"\"\"\n    Set the labels of the atoms to displace and update the unique labels. This function should always be used to set the labels.\n\n    Parameters\n    ----------\n    new_labels : IntegerArray\n        The new labels of the atoms to displace.\n    \"\"\"\n    self.labels: IntegerArray = np.asarray(new_labels)\n    self.unique_labels: IntegerArray = np.unique(self.labels[self.labels &gt;= 0])\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.DisplacementMove.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>DisplacementMove</code> object to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>DisplacementMove</code> object.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `DisplacementMove` object to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `DisplacementMove` object.\n    \"\"\"\n    dictionary = super().to_dict()\n    dictionary.setdefault(\"kwargs\", {})[\"labels\"] = self.labels\n    dictionary.setdefault(\"attributes\", {})[\"default_label\"] = self.default_label\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.HamiltonianDisplacementMove","title":"HamiltonianDisplacementMove","text":"<pre><code>HamiltonianDisplacementMove(distribution=maxwell_boltzmann_distribution, operation=None)\n</code></pre> <p>               Bases: <code>BaseMove[IntegratorType, HContextType]</code>, <code>Generic[IntegratorType, HContextType]</code></p> <p>Class for Hamiltonian displacement moves that displaces atoms using a Hamiltonian integrator. The class uses the <code>distribution</code> attribute to sample momenta from a distribution before attempting the move. The class will use an [<code>Integrator</code>][quansino.integrators.core.Integrator] to perform the move.</p> <p>Parameters:</p> <ul> <li> <code>distribution</code>               (<code>Callable[[DisplacementContext], None]</code>, default:                   <code>maxwell_boltzmann_distribution</code> )           \u2013            <p>The distribution to sample momenta from before attempting the move, by default <code>maxwell_boltzmann_distribution</code>.</p> </li> <li> <code>operation</code>               (<code>OperationType | None</code>, default:                   <code>None</code> )           \u2013            <p>The operation to perform in the move, by default None.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>)           \u2013            <p>Whether to apply constraints to the move, by default True.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def __init__(\n    self,\n    distribution: Callable[\n        [DisplacementContext], None\n    ] = maxwell_boltzmann_distribution,\n    operation: IntegratorType | None = None,\n) -&gt; None:\n    \"\"\"Initialize the `HMCDisplacementMove` object.\"\"\"\n    super().__init__(operation, apply_constraints=True)\n\n    self.max_attempts: int = 10\n    self.distribution: Callable[[HContextType], None] = distribution\n</code></pre>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.HamiltonianDisplacementMove.default_operation","title":"default_operation  <code>property</code>","text":"<pre><code>default_operation\n</code></pre> <p>Get the default operation for the move.</p> <p>Returns:</p> <ul> <li> <code>OperationType</code>           \u2013            <p>The default operation for the move.</p> </li> </ul>"},{"location":"reference/quansino/moves/displacement.html#quansino.moves.displacement.HamiltonianDisplacementMove.attempt_displacement","title":"attempt_displacement","text":"<pre><code>attempt_displacement(context, sample_momenta=True)\n</code></pre> <p>Attempt to move the atoms using the provided integrator and check against <code>check_move</code>. The move is attempted <code>max_attempts</code> number of times. If the move is successful, return True, otherwise, return False.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context for the move.</p> </li> <li> <code>sample_momenta</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to sample the momenta from the distribution before attempting the move, by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/displacement.py</code> <pre><code>def attempt_displacement(\n    self, context: HContextType, sample_momenta: bool = True\n) -&gt; bool:\n    \"\"\"\n    Attempt to move the atoms using the provided integrator and check against `check_move`. The move is attempted `max_attempts` number of times. If the move is successful, return True, otherwise, return False.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context for the move.\n    sample_momenta : bool, optional\n        Whether to sample the momenta from the distribution before attempting the move, by default True.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    atoms = context.atoms\n    old_positions = atoms.get_positions()\n    old_momenta = atoms.get_momenta()\n\n    for _ in range(self.max_attempts):\n        if sample_momenta:\n            self.distribution(context)\n            context.last_kinetic_energy = atoms.get_kinetic_energy()  # type: ignore\n\n        self.operation.integrate(context)\n\n        if self.check_move(context):\n            return True\n\n        atoms.positions = old_positions\n        atoms.set_array(\"momenta\", old_momenta, float, (3,))\n        Context.revert_state(context)\n\n    return False\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html","title":"exchange","text":"<p>Module for the ExchangeMove class.</p>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.CompositeExchangeMove","title":"CompositeExchangeMove","text":"<pre><code>CompositeExchangeMove(moves)\n</code></pre> <p>               Bases: <code>CompositeMove[ExchangeMove]</code></p> <p>Parameters:</p> <ul> <li> <code>moves</code>               (<code>list[ExchangeMove]</code>)           \u2013            <p>The moves to perform in the composite move.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def __init__(self, moves: list[ExchangeMove]) -&gt; None:\n    \"\"\"\n    Initialize the CompositeExchangeMove object.\n\n    Parameters\n    ----------\n    moves : list[ExchangeMove]\n        The moves to perform in the composite move.\n    \"\"\"\n    super().__init__(moves)\n\n    self.bias_towards_insert: float = 0.5\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.CompositeExchangeMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the composite exchange move. The following steps are performed:</p> <ol> <li>Decide whether to perform addition or deletion based on the <code>bias_towards_insert</code> attribute. This will be the same for all moves in the composite, if you want to have different biases for each move, use the <code>CompositeMove</code> class with individual <code>ExchangeMove</code> objects.</li> <li>For addition moves, attempt to add atoms using attempt_addition(). If successful, register the success.</li> <li>For deletion moves, filter out already deleted labels to avoid conflicts, then select an available candidate from unique_labels. If no candidates are available, register deletion failure and continue to next move.</li> <li>For valid deletion candidates, set the move's to_delete_label and attempt deletion. If successful, register the deletion success.</li> <li>Return True if any of the individual moves were successful, False otherwise.</li> </ol> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether any of the exchange moves in the composite were valid.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def __call__(self, context: ExchangeContext) -&gt; bool:\n    \"\"\"\n    Perform the composite exchange move. The following steps are performed:\n\n    1. Decide whether to perform addition or deletion based on the `bias_towards_insert` attribute. This will be the same for all moves in the composite, if you want to have different biases for each move, use the `CompositeMove` class with individual `ExchangeMove` objects.\n    2. For addition moves, attempt to add atoms using attempt_addition(). If successful, register the success.\n    3. For deletion moves, filter out already deleted labels to avoid conflicts, then select an available candidate from unique_labels. If no candidates are available, register deletion failure and continue to next move.\n    4. For valid deletion candidates, set the move's to_delete_label and attempt deletion. If successful, register the deletion success.\n    5. Return True if any of the individual moves were successful, False otherwise.\n\n    Returns\n    -------\n    bool\n        Whether any of the exchange moves in the composite were valid.\n    \"\"\"\n    is_addition = context.rng.random() &lt; self.bias_towards_insert\n\n    if is_addition:\n        success = False\n\n        for move in self.moves:\n            indices = move.attempt_addition(context)\n\n            if len(indices):\n                context._added_indices = np.hstack(\n                    (context._added_indices, indices),\n                    dtype=np.int_,\n                    casting=\"unsafe\",\n                )\n                context._added_atoms += context.atoms[indices]\n                context.particle_delta += 1\n                success = True\n\n            move.to_add_atoms = None\n        return success\n    else:\n        deleted_labels = []\n        deleted_indices = np.array([], dtype=np.int_)\n\n        for move in self.moves:\n            available_candidates = np.setdiff1d(\n                move.unique_labels, deleted_labels, assume_unique=True\n            )\n            if len(available_candidates) == 0:\n                continue\n\n            to_delete_label = context.rng.choice(available_candidates)\n\n            (indices,) = np.where(move.labels == to_delete_label)\n\n            deleted_indices = np.hstack(\n                (deleted_indices, indices), dtype=np.int_, casting=\"unsafe\"\n            )\n            deleted_labels.append(to_delete_label)\n\n        if len(deleted_indices) == 0:\n            return False\n\n        context._deleted_indices = deleted_indices\n        context._deleted_atoms += context.atoms[deleted_indices]\n        context.particle_delta -= len(np.unique(deleted_labels))\n\n        del context.atoms[deleted_indices]\n\n        return True\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove","title":"ExchangeMove","text":"<pre><code>ExchangeMove(labels, operation=None, bias_towards_insert=0.5, apply_constraints=True)\n</code></pre> <p>               Bases: <code>DisplacementMove[OperationType, ContextType]</code>, <code>Generic[OperationType, ContextType]</code></p> <p>Class for atomic/molecular exchange moves that exchanges atom(s). The class will either add <code>exchange_atoms</code> in the unit cell or delete a (group) of atom(s) present in <code>labels</code>.</p> <p>For addition, the move uses the <code>attempt_move</code> method in the parent <code>DisplacementMove</code> class with the provided <code>operation</code> (Translation by default for single atoms, TranslationRotation for multiple atoms).</p> <p>For deletion, the move will attempt to remove atoms with non-negative labels from the parent class <code>DisplacementMove</code>. The context's <code>save_state()</code> method must be called after successful moves to update the <code>labels</code> of other <code>DisplacementMoves</code> linked to the simulation.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>IntegerArray</code>)           \u2013            <p>The labels of the atoms that can be exchanged (already present).</p> </li> <li> <code>operation</code>               (<code>Operation | None</code>, default:                   <code>None</code> )           \u2013            <p>The operation to perform in the move, default is None, which will use the default operation (Translation).</p> </li> <li> <code>bias_towards_insert</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The probability of inserting atoms instead of deleting, default is 0.5.</p> </li> <li> <code>apply_constraints</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to apply constraints during the move, default is True.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>bias_towards_insert</code>               (<code>float</code>)           \u2013            <p>The probability of inserting atoms instead of deleting, can be used to bias the move towards insertion or deletion.</p> </li> <li> <code>to_add_atoms</code>               (<code>Atoms | None</code>)           \u2013            <p>The atoms to add during the next move, reset after each move.</p> </li> <li> <code>to_delete_label</code>               (<code>int | None</code>)           \u2013            <p>The indices of the atoms to delete during the next move, reset after each move.</p> </li> </ul> Important <ol> <li>At object creation, <code>labels</code> must have the same length as the number of atoms in the simulation.</li> <li>Any labels that are not negative integers are considered exchangeable (deletable).</li> <li>Atoms that share the same label are considered to be part of the same group (molecule) and will be deleted together.</li> <li>Monte Carlo simulations like <code>GrandCanonical</code> will automatically update the labels of all linked moves to keep them in sync.</li> </ol> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def __init__(\n    self,\n    labels: IntegerArray,\n    operation: OperationType | None = None,\n    bias_towards_insert: float = 0.5,\n    apply_constraints: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the ExchangeMove object.\"\"\"\n    self.bias_towards_insert = bias_towards_insert\n\n    self.to_add_atoms: Atoms | None = None\n    self.to_delete_label: int | None = None\n\n    super().__init__(labels, operation, apply_constraints)\n\n    self.composite_move_type = CompositeExchangeMove\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.default_operation","title":"default_operation  <code>property</code>","text":"<pre><code>default_operation\n</code></pre> <p>Get the default operation for the exchange move.</p> <p>Returns:</p> <ul> <li> <code>Operation</code>           \u2013            <p>The default operation, which is Translation for single atoms or TranslationRotation for molecules.</p> </li> </ul>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.__call__","title":"__call__","text":"<pre><code>__call__(context)\n</code></pre> <p>Perform the exchange move. The following steps are performed:</p> <ol> <li>Decide whether to insert or delete atoms, this can be pre-selected by setting the <code>to_add_atoms</code> or <code>to_delete_label</code> attributes before calling the move. If not, the decision is made randomly based on the <code>bias_towards_insert</code> attribute.</li> <li>If adding atoms, add the atoms to the atoms object and attempt to place them using the parent class <code>DisplacementMove.attempt_displacement</code>. If the move is not successful, remove the atoms from the atoms object and register the exchange failure. If deleting atoms, remove the atoms from the atoms object, failure is only possible if all labels are negative integers (no atoms to delete).</li> <li>During these steps, attributes in the context object are updated to keep track of the move and can be used later for multiple purposes such as calculating the acceptance probability.</li> </ol> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the move was valid.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def __call__(self, context: ContextType) -&gt; bool:\n    \"\"\"\n    Perform the exchange move. The following steps are performed:\n\n    1. Decide whether to insert or delete atoms, this can be pre-selected by setting the `to_add_atoms` or `to_delete_label` attributes before calling the move. If not, the decision is made randomly based on the `bias_towards_insert` attribute.\n    2. If adding atoms, add the atoms to the atoms object and attempt to place them using the parent class [`DisplacementMove.attempt_displacement`][quansino.moves.displacement.DisplacementMove.attempt_displacement]. If the move is not successful, remove the atoms from the atoms object and register the exchange failure. If deleting atoms, remove the atoms from the atoms object, failure is only possible if all labels are negative integers (no atoms to delete).\n    3. During these steps, attributes in the context object are updated to keep track of the move and can be used later for multiple purposes such as calculating the acceptance probability.\n\n    Returns\n    -------\n    bool\n        Whether the move was valid.\n    \"\"\"\n    if self.to_add_atoms is None and self.to_delete_label is None:\n        is_addition = context.rng.random() &lt; self.bias_towards_insert\n    else:\n        is_addition = bool(self.to_add_atoms)\n\n    if is_addition:\n        indices = self.attempt_addition(context)\n\n        if len(indices):\n            context._added_indices = np.hstack(\n                (context._added_indices, indices), dtype=np.int_, casting=\"unsafe\"\n            )\n            context._added_atoms += context.atoms[indices]\n            context.particle_delta += 1\n\n            return self.register_success()\n    else:\n        indices = self.attempt_deletion(context)\n\n        if len(indices):\n            context._deleted_indices = np.hstack(\n                (context._deleted_indices, indices), dtype=np.int_, casting=\"unsafe\"\n            )\n            context._deleted_atoms += context.atoms[indices]\n            context.particle_delta -= 1\n\n            del context.atoms[indices]\n            return self.register_success()\n\n    return self.register_failure()\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.attempt_addition","title":"attempt_addition","text":"<pre><code>attempt_addition(context)\n</code></pre> <p>Attempt to add atoms to the simulation. If <code>to_add_atoms</code> is not set, it will use the <code>exchange_atoms</code> from the context.</p> <p>Returns:</p> <ul> <li> <code>IntegerArray</code>           \u2013            <p>The indices of the added atoms.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def attempt_addition(self, context: ContextType) -&gt; IntegerArray:\n    \"\"\"\n    Attempt to add atoms to the simulation. If `to_add_atoms` is not set, it will use the `exchange_atoms` from the context.\n\n    Returns\n    -------\n    IntegerArray\n        The indices of the added atoms.\n    \"\"\"\n    self.to_add_atoms = self.to_add_atoms or context.exchange_atoms\n\n    context.atoms.extend(self.to_add_atoms)\n    context._moving_indices = np.arange(len(context.atoms))[\n        -len(self.to_add_atoms) :\n    ]\n\n    if not super().attempt_displacement(context):\n        del context.atoms[context._moving_indices]\n        return []\n\n    return context._moving_indices\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.attempt_deletion","title":"attempt_deletion","text":"<pre><code>attempt_deletion(context)\n</code></pre> <p>Attempt to delete atoms from the simulation. If <code>to_delete_label</code> is not set, it will randomly select a label from the unique labels of the context.</p> <p>Returns:</p> <ul> <li> <code>IntegerArray</code>           \u2013            <p>The indices of the deleted atoms.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def attempt_deletion(self, context: ContextType) -&gt; IntegerArray:\n    \"\"\"\n    Attempt to delete atoms from the simulation. If `to_delete_label` is not set, it will randomly select a label from the unique labels of the context.\n\n    Returns\n    -------\n    IntegerArray\n        The indices of the deleted atoms.\n    \"\"\"\n    if self.to_delete_label is None:\n        if not len(self.unique_labels):\n            return []\n\n        self.to_delete_label = int(context.rng.choice(self.unique_labels))\n\n    (indices,) = np.where(self.labels == self.to_delete_label)\n\n    if not len(indices):\n        return []\n\n    return indices\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.register_failure","title":"register_failure","text":"<pre><code>register_failure()\n</code></pre> <p>Register a failed exchange move, in which case all information is retained except the prior move attributes.</p> <p>Returns:</p> <ul> <li> <code>Literal[False]</code>           \u2013            <p>Always returns False.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def register_failure(self) -&gt; Literal[False]:\n    \"\"\"\n    Register a failed exchange move, in which case all information is retained except the prior move attributes.\n\n    Returns\n    -------\n    Literal[False]\n        Always returns False.\n    \"\"\"\n    self.to_add_atoms = None\n    self.to_delete_label = None\n\n    return False\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.register_success","title":"register_success","text":"<pre><code>register_success()\n</code></pre> <p>Register a successful exchange move, in which case all information is retained except the prior move attributes.</p> <p>Returns:</p> <ul> <li> <code>Literal[True]</code>           \u2013            <p>Always returns True.</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def register_success(self) -&gt; Literal[True]:\n    \"\"\"\n    Register a successful exchange move, in which case all information is retained except the prior move attributes.\n\n    Returns\n    -------\n    Literal[True]\n        Always returns True.\n    \"\"\"\n    self.to_add_atoms = None\n    self.to_delete_label = None\n\n    return True\n</code></pre>"},{"location":"reference/quansino/moves/exchange.html#quansino.moves.exchange.ExchangeMove.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the ExchangeMove object to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the <code>ExchangeMove</code> object</p> </li> </ul> Source code in <code>quansino/moves/exchange.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the ExchangeMove object to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the `ExchangeMove` object\n    \"\"\"\n    dictionary = super().to_dict()\n\n    kwargs = dictionary.setdefault(\"kwargs\", {})\n    kwargs[\"bias_towards_insert\"] = self.bias_towards_insert\n\n    return dictionary\n</code></pre>"},{"location":"reference/quansino/operations/cell.html","title":"cell","text":""},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.AnisotropicDeformation","title":"AnisotropicDeformation","text":"<pre><code>AnisotropicDeformation(max_value, mask=None)\n</code></pre> <p>               Bases: <code>DeformationOperation</code></p> <p>Class for anisotropic deformation operation that can deform the cell differently along each axis.</p> <p>This operation applies a deformation tensor with randomly generated components to the simulation cell. The tensor is constructed using exponential mapping to ensure that the resulting deformation is positive definite. If max_value is large, the true maximum component values may exceed it, use with caution.</p> Source code in <code>quansino/operations/cell.py</code> <pre><code>def __init__(self, max_value: float, mask: NDArray[np.bool] | None = None) -&gt; None:\n    \"\"\"Initialize the `DeformationOperation` object.\"\"\"\n    self.max_value = max_value\n\n    self.mask = np.ones((3, 3), dtype=bool) if mask is None else mask\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.AnisotropicDeformation.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate an anisotropic deformation tensor.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The simulation context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Deformation</code>           \u2013            <p>A 3x3 deformation tensor.</p> </li> </ul> Source code in <code>quansino/operations/cell.py</code> <pre><code>def calculate(self, context: Context) -&gt; Deformation:\n    \"\"\"\n    Calculate an anisotropic deformation tensor.\n\n    Parameters\n    ----------\n    context : Context\n        The simulation context.\n\n    Returns\n    -------\n    Deformation\n        A 3x3 deformation tensor.\n    \"\"\"\n    deformation_tensor = np.zeros((3, 3), dtype=np.float64)\n    components = context.rng.uniform(-self.max_value, self.max_value, size=6)\n\n    deformation_tensor[0, 0] = components[0]\n    deformation_tensor[1, 1] = components[1]\n    deformation_tensor[2, 2] = components[2]\n\n    deformation_tensor[0, 1] = components[3]\n    deformation_tensor[0, 2] = components[4]\n    deformation_tensor[1, 2] = components[5]\n\n    deformation_tensor[1, 0] = deformation_tensor[0, 1]\n    deformation_tensor[2, 0] = deformation_tensor[0, 2]\n    deformation_tensor[2, 1] = deformation_tensor[1, 2]\n\n    return expm(deformation_tensor) * self.mask + np.eye(3) * (~self.mask)\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.DeformationOperation","title":"DeformationOperation","text":"<pre><code>DeformationOperation(max_value, mask=None)\n</code></pre> <p>               Bases: <code>BaseOperation</code></p> <p>Base class for deformation operations that may modify the simulation cell or atoms' positions.</p> <p>Parameters:</p> <ul> <li> <code>max_value</code>               (<code>float</code>)           \u2013            <p>The maximum deformation value for the operation, determines the magnitude of the deformation.</p> </li> <li> <code>mask</code>               (<code>NDArray[bool]</code>, default:                   <code>None</code> )           \u2013            <p>A boolean array indicating which directions are allowed to deform. True values indicate allowed directions. Must be a 3x3 array.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>max_value</code>               (<code>float</code>)           \u2013            <p>The maximum deformation parameter controlling the deformation magnitude.</p> </li> </ul> Source code in <code>quansino/operations/cell.py</code> <pre><code>def __init__(self, max_value: float, mask: NDArray[np.bool] | None = None) -&gt; None:\n    \"\"\"Initialize the `DeformationOperation` object.\"\"\"\n    self.max_value = max_value\n\n    self.mask = np.ones((3, 3), dtype=bool) if mask is None else mask\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.DeformationOperation.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the operation to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The dictionary representation of the operation.</p> </li> </ul> Source code in <code>quansino/operations/cell.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the operation to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        The dictionary representation of the operation.\n    \"\"\"\n    return {**super().to_dict(), \"kwargs\": {\"max_value\": self.max_value}}\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.IsotropicDeformation","title":"IsotropicDeformation","text":"<pre><code>IsotropicDeformation(max_value, mask=None)\n</code></pre> <p>               Bases: <code>DeformationOperation</code></p> <p>Class for isotropic deformation operations that stretch or compress the cell equally in all directions.</p> <p>This operation applies the same deformation value to all diagonal components of the deformation tensor, resulting in uniform scaling of the simulation cell.</p> Source code in <code>quansino/operations/cell.py</code> <pre><code>def __init__(self, max_value: float, mask: NDArray[np.bool] | None = None) -&gt; None:\n    \"\"\"Initialize the `DeformationOperation` object.\"\"\"\n    self.max_value = max_value\n\n    self.mask = np.ones((3, 3), dtype=bool) if mask is None else mask\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.IsotropicDeformation.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate an isotropic stretch deformation tensor.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The simulation context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Deformation</code>           \u2013            <p>A 3x3 deformation tensor with identical diagonal elements.</p> </li> </ul> Source code in <code>quansino/operations/cell.py</code> <pre><code>def calculate(self, context: Context) -&gt; Deformation:\n    \"\"\"\n    Calculate an isotropic stretch deformation tensor.\n\n    Parameters\n    ----------\n    context : Context\n        The simulation context.\n\n    Returns\n    -------\n    Deformation\n        A 3x3 deformation tensor with identical diagonal elements.\n    \"\"\"\n    return np.eye(3) * exp(\n        context.rng.uniform(-self.max_value, self.max_value)\n    ) * self.mask + np.eye(3) * (~self.mask)\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.ShapeDeformation","title":"ShapeDeformation","text":"<pre><code>ShapeDeformation(max_value, mask=None)\n</code></pre> <p>               Bases: <code>DeformationOperation</code></p> <p>Class for anisotropic deformation operations that can deform the cell differently along each axis.</p> <p>This operation applies a deformation tensor with randomly generated components to the simulation cell. The tensor is constructed using exponential mapping to ensure that the resulting deformation is positive definite. If max_value is large, the true maximum component values may exceed it, use with caution.</p> Source code in <code>quansino/operations/cell.py</code> <pre><code>def __init__(self, max_value: float, mask: NDArray[np.bool] | None = None) -&gt; None:\n    \"\"\"Initialize the `DeformationOperation` object.\"\"\"\n    self.max_value = max_value\n\n    self.mask = np.ones((3, 3), dtype=bool) if mask is None else mask\n</code></pre>"},{"location":"reference/quansino/operations/cell.html#quansino.operations.cell.ShapeDeformation.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate a volume preserving, anisotropic deformation tensor.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The simulation context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Deformation</code>           \u2013            <p>A 3x3 deformation tensor.</p> </li> </ul> Source code in <code>quansino/operations/cell.py</code> <pre><code>def calculate(self, context: Context) -&gt; Deformation:\n    \"\"\"\n    Calculate a volume preserving, anisotropic deformation tensor.\n\n    Parameters\n    ----------\n    context : Context\n        The simulation context.\n\n    Returns\n    -------\n    Deformation\n        A 3x3 deformation tensor.\n    \"\"\"\n    deformation_tensor = np.zeros((3, 3), dtype=np.float64)\n    components = context.rng.uniform(-self.max_value, self.max_value, size=6)\n\n    deformation_tensor[0, 1] = components[3]\n    deformation_tensor[0, 2] = components[4]\n    deformation_tensor[1, 2] = components[5]\n\n    deformation_tensor[1, 0] = deformation_tensor[0, 1]\n    deformation_tensor[2, 0] = deformation_tensor[0, 2]\n    deformation_tensor[2, 1] = deformation_tensor[1, 2]\n\n    diag_mean = (components[0] + components[1] + components[2]) / 3.0\n\n    deformation_tensor[0, 0] = components[0] - diag_mean\n    deformation_tensor[1, 1] = components[1] - diag_mean\n    deformation_tensor[2, 2] = components[2] - diag_mean\n\n    return expm(deformation_tensor) * self.mask + np.eye(3) * (~self.mask)\n</code></pre>"},{"location":"reference/quansino/operations/composite.html","title":"composite","text":""},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation","title":"CompositeOperation","text":"<pre><code>CompositeOperation(operations)\n</code></pre> <p>               Bases: <code>Generic[OperationType]</code></p> <p>Class to combine multiple operations into a single operation.</p> <p>This class allows for the combination of multiple operations of the same type, which are executed sequentially and their results combined. Operations can be accessed by index, iterated over, and the class supports addition and multiplication operations.</p> <p>Parameters:</p> <ul> <li> <code>operations</code>               (<code>list[OperationType]</code>)           \u2013            <p>The operations to combine into a single operation. All operations must be of the same type specified by the OperationType generic parameter.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>operations</code>               (<code>list[OperationType]</code>)           \u2013            <p>The list of operations to be executed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The combined result of all operations, typically the sum of their individual results.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>def __init__(self, operations: list[OperationType]) -&gt; None:\n    \"\"\"Initialize the CompositeOperation object.\"\"\"\n    if len(operations) == 0:\n        warn(\n            f\"No operations provided. The {self.__class__.__name__} will not perform any calculations.\",\n            UserWarning,\n            2,\n        )\n\n    self.operations = operations\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.__add__","title":"__add__","text":"<pre><code>__add__(other: CompositeOperation[OperationType]) -&gt; CompositeOperation[OperationType]\n</code></pre><pre><code>__add__(other: CompositeOperation) -&gt; CompositeOperation[Operation]\n</code></pre><pre><code>__add__(other: OperationType) -&gt; CompositeOperation[OperationType]\n</code></pre><pre><code>__add__(other) -&gt; CompositeOperation[Operation]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Combine two operations into a single operation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Operation</code>)           \u2013            <p>The operation to combine with the current operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The combined operation of the same type as the caller.</p> </li> </ul> Notes <p>Works with both single operations and composite operations. If the other operation is a composite operation, the operations are combined into a single composite operation.</p> Source code in <code>quansino/operations/composite.py</code> <pre><code>def __add__(self, other) -&gt; CompositeOperation:\n    \"\"\"\n    Combine two operations into a single operation.\n\n    Parameters\n    ----------\n    other : Operation\n        The operation to combine with the current operation.\n\n    Returns\n    -------\n    Self\n        The combined operation of the same type as the caller.\n\n    Notes\n    -----\n    Works with both single operations and composite operations. If the other operation is a composite operation, the operations are combined into a single composite operation.\n    \"\"\"\n    if isinstance(other, CompositeOperation):\n        return type(self)(self.operations + other.operations)\n    else:\n        other = cast(\"OperationType\", other)\n        return self.__class__([*self.operations, other])\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Get the move at the specified index.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>The index of the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DisplacementMove</code>           \u2013            <p>The move at the specified index.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>def __getitem__(self, index: int) -&gt; OperationType:\n    \"\"\"\n    Get the move at the specified index.\n\n    Parameters\n    ----------\n    index : int\n        The index of the move.\n\n    Returns\n    -------\n    DisplacementMove\n        The move at the specified index.\n    \"\"\"\n    return self.operations[index]\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.__mul__","title":"__mul__","text":"<pre><code>__mul__(n)\n</code></pre> <p>Multiply the displacement move by an integer to create a composite move.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of times to repeat the move.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeDisplacementMove</code>           \u2013            <p>The composite move.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>def __mul__(self, n: int) -&gt; Self:\n    \"\"\"\n    Multiply the displacement move by an integer to create a composite move.\n\n    Parameters\n    ----------\n    n : int\n        The number of times to repeat the move.\n\n    Returns\n    -------\n    CompositeDisplacementMove\n        The composite move.\n    \"\"\"\n    if n &lt; 1 or not isinstance(n, int):\n        raise ValueError(\n            \"The number of times the move is repeated must be a positive, non-zero integer.\"\n        )\n    return type(self)(self.operations * n)\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate the combined operation to perform on the atoms.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>ContextType</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>The combined operation to perform on the atoms.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>def calculate(self, context: Context) -&gt; Any:\n    \"\"\"\n    Calculate the combined operation to perform on the atoms.\n\n    Parameters\n    ----------\n    context : ContextType\n        The context to use when calculating the operation.\n\n    Returns\n    -------\n    Displacement\n        The combined operation to perform on the atoms.\n    \"\"\"\n    return np.sum([op.calculate(context) for op in self.operations], axis=0)\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create a composite operation from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The composite operation object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create a composite operation from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the operation.\n\n    Returns\n    -------\n    Self\n        The composite operation object created from the dictionary.\n    \"\"\"\n    operations = []\n\n    kwargs = deepcopy(data.get(\"kwargs\", {}))\n\n    if \"operations\" in kwargs:\n        for operation_data in kwargs[\"operations\"]:\n            operation_class: type[Operation] = get_typed_class(\n                operation_data[\"name\"], Operation\n            )\n            operation = operation_class.from_dict(operation_data)\n            operations.append(operation)\n\n    kwargs[\"operations\"] = operations\n\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/operations/composite.html#quansino.operations.composite.CompositeOperation.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the operation to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The dictionary representation of the operation.</p> </li> </ul> Source code in <code>quansino/operations/composite.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the operation to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        The dictionary representation of the operation.\n    \"\"\"\n    return {\n        \"name\": self.__class__.__name__,\n        \"kwargs\": {\n            \"operations\": [operation.to_dict() for operation in self.operations]\n        },\n    }\n</code></pre>"},{"location":"reference/quansino/operations/core.html","title":"core","text":""},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation","title":"BaseOperation","text":"<p>Abstract base class for operations in Monte Carlo simulations.</p> <p>This class defines the interface for all operations that can be performed during Monte Carlo moves. Implementations must provide a <code>calculate</code> method that computes the operation based on the given context.</p> <p>Operations can be combined using the <code>+</code> operator or multiplied using the <code>*</code> operator to create composite operations.</p>"},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation.__add__","title":"__add__","text":"<pre><code>__add__(other: Operation) -&gt; CompositeOperation[Operation]\n</code></pre><pre><code>__add__(other: CompositeOperation[OperationType]) -&gt; CompositeOperation[OperationType]\n</code></pre><pre><code>__add__(other: OperationType) -&gt; CompositeOperation[OperationType]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Combine two operations into a single operation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Operation</code>)           \u2013            <p>The operation to combine with the current operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeOperation</code>           \u2013            <p>The combined operation.</p> </li> </ul> Notes <p>Works with both single operations and composite operations. If the other operation is a composite operation, the operations are combined into a single composite operation.</p> Source code in <code>quansino/operations/core.py</code> <pre><code>def __add__(self, other) -&gt; CompositeOperation:\n    \"\"\"\n    Combine two operations into a single operation.\n\n    Parameters\n    ----------\n    other : Operation\n        The operation to combine with the current operation.\n\n    Returns\n    -------\n    CompositeOperation\n        The combined operation.\n\n    Notes\n    -----\n    Works with both single operations and composite operations. If the other operation is a composite operation, the operations are combined into a single composite operation.\n    \"\"\"\n    if isinstance(other, CompositeOperation):\n        return CompositeOperation([self, *other.operations])\n    else:\n        return CompositeOperation([self, other])\n</code></pre>"},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation.__mul__","title":"__mul__","text":"<pre><code>__mul__(n)\n</code></pre> <p>Multiply the operation by an integer to create a composite operation.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of times to repeat the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompositeOperation</code>           \u2013            <p>The composite operation.</p> </li> </ul> Source code in <code>quansino/operations/core.py</code> <pre><code>def __mul__(self, n: int) -&gt; CompositeOperation[Self]:\n    \"\"\"\n    Multiply the operation by an integer to create a composite operation.\n\n    Parameters\n    ----------\n    n : int\n        The number of times to repeat the operation.\n\n    Returns\n    -------\n    CompositeOperation\n        The composite operation.\n    \"\"\"\n    if n &lt; 1 or not isinstance(n, int):\n        raise ValueError(\n            \"The number of times the move is repeated must be a positive, non-zero integer.\"\n        )\n\n    return CompositeOperation([self] * n)\n</code></pre>"},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation.calculate","title":"calculate","text":"<pre><code>calculate(context, *args, **kwargs)\n</code></pre> <p>Calculate the operation to perform based on the given context.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Additional positional arguments for the operation.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the calculation, typically a displacement or strain tensor.</p> </li> </ul> Source code in <code>quansino/operations/core.py</code> <pre><code>def calculate(self, context: Context, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Calculate the operation to perform based on the given context.\n\n    Parameters\n    ----------\n    context : Context\n        The context to use when calculating the operation.\n    *args : Any\n        Additional positional arguments for the operation.\n    **kwargs : Any\n        Additional keyword arguments for the operation.\n\n    Returns\n    -------\n    Any\n        The result of the calculation, typically a displacement or strain tensor.\n    \"\"\"\n</code></pre>"},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Create an <code>Operation</code> object from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary representation of the <code>Operation</code> object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The <code>Operation</code> object created from the dictionary.</p> </li> </ul> Source code in <code>quansino/operations/core.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Create an `Operation` object from a dictionary.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        The dictionary representation of the `Operation` object.\n\n    Returns\n    -------\n    Self\n        The `Operation` object created from the dictionary.\n    \"\"\"\n    kwargs = data.get(\"kwargs\", {})\n    instance = cls(**kwargs)\n\n    for key, value in data.get(\"attributes\", {}).items():\n        setattr(instance, key, value)\n\n    return instance\n</code></pre>"},{"location":"reference/quansino/operations/core.html#quansino.operations.core.BaseOperation.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the <code>Operation</code> object to a dictionary representation.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The dictionary representation of the <code>Operation</code> object.</p> </li> </ul> Source code in <code>quansino/operations/core.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the `Operation` object to a dictionary representation.\n\n    Returns\n    -------\n    dict[str, Any]\n        The dictionary representation of the `Operation` object.\n    \"\"\"\n    return {\"name\": self.__class__.__name__}\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html","title":"displacement","text":""},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Ball","title":"Ball","text":"<pre><code>Ball(step_size=1.0)\n</code></pre> <p>               Bases: <code>DisplacementOperation</code></p> <p>Class for a ball-shaped displacement operation that places atoms within a sphere.</p> <p>Unlike the Sphere operation, this operation generates displacements where atoms can be placed anywhere within the volume of a sphere with maximum radius equal to step_size.</p> <p>Parameters:</p> <ul> <li> <code>step_size</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The maximum radius of the ball (default is 1.0).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector placing atoms within the volume of a sphere.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def __init__(self, step_size: float = 1.0) -&gt; None:\n    self.step_size = step_size\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Ball.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate the spherical operation to perform on the atoms.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>The spherical operation to perform on the atoms.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def calculate(self, context: DisplacementContext) -&gt; Displacement:\n    \"\"\"\n    Calculate the spherical operation to perform on the atoms.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The context to use when calculating the operation.\n\n    Returns\n    -------\n    Displacement\n        The spherical operation to perform on the atoms.\n    \"\"\"\n    r = context.rng.uniform(0, self.step_size, size=1)\n    phi = context.rng.uniform(0, 2 * np.pi, size=1)\n    cos_theta = context.rng.uniform(-1, 1, size=1)\n    sin_theta = np.sqrt(1 - cos_theta**2)\n\n    return np.column_stack(\n        (r * sin_theta * np.cos(phi), r * sin_theta * np.sin(phi), r * cos_theta)\n    )\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Box","title":"Box","text":"<pre><code>Box(step_size=1.0)\n</code></pre> <p>               Bases: <code>DisplacementOperation</code></p> <p>Class for a box-shaped displacement operation.</p> <p>This operation generates random displacements within a box with dimensions determined by the step_size parameter. Displacements are uniformly distributed in the range [-step_size, step_size] along each axis.</p> <p>Parameters:</p> <ul> <li> <code>step_size</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The maximum displacement along each axis (default is 1.0).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A box-shaped displacement vector for the selected atoms.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def __init__(self, step_size: float = 1.0) -&gt; None:\n    self.step_size = step_size\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.DisplacementOperation","title":"DisplacementOperation","text":"<pre><code>DisplacementOperation(step_size=1.0)\n</code></pre> <p>               Bases: <code>BaseOperation</code></p> <p>Base class for displacement operations.</p> <p>Parameters:</p> <ul> <li> <code>step_size</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The step size for the displacement operation (default is 1.0).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>step_size</code>               (<code>float</code>)           \u2013            <p>The step size for the displacement operation.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def __init__(self, step_size: float = 1.0) -&gt; None:\n    self.step_size = step_size\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.DisplacementOperation.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the operation to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the operation.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the operation to a dictionary.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the operation.\n    \"\"\"\n    return {**super().to_dict(), \"kwargs\": {\"step_size\": self.step_size}}\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Rotation","title":"Rotation","text":"<p>               Bases: <code>BaseOperation</code></p> <p>Class for a rotation operation.</p> <p>This operation rotates the selected atoms around their center of mass using randomly generated Euler angles. The rotation is performed around the center of mass of the selected atoms.</p> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector representing the rotational movement of the selected atoms.</p> </li> </ul>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Sphere","title":"Sphere","text":"<pre><code>Sphere(step_size=1.0)\n</code></pre> <p>               Bases: <code>DisplacementOperation</code></p> <p>Class for a spherical displacement operation that places atoms on the surface of a sphere.</p> <p>This operation generates displacements where atoms are placed exactly at a distance equal to step_size from the origin, creating a spherical shell pattern.</p> <p>Parameters:</p> <ul> <li> <code>step_size</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The radius of the sphere (default is 1.0).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector placing atoms on the surface of a sphere.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def __init__(self, step_size: float = 1.0) -&gt; None:\n    self.step_size = step_size\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Sphere.calculate","title":"calculate","text":"<pre><code>calculate(context)\n</code></pre> <p>Calculate the spherical operation to perform on the atoms.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The context to use when calculating the operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>The spherical operation to perform on the atoms.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def calculate(self, context: DisplacementContext) -&gt; Displacement:\n    \"\"\"\n    Calculate the spherical operation to perform on the atoms.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The context to use when calculating the operation.\n\n    Returns\n    -------\n    Displacement\n        The spherical operation to perform on the atoms.\n    \"\"\"\n    phi = context.rng.uniform(0, 2 * np.pi, size=1)\n    cos_theta = context.rng.uniform(-1, 1, size=1)\n    sin_theta = np.sqrt(1 - cos_theta**2)\n\n    return self.step_size * np.column_stack(\n        (sin_theta * np.cos(phi), sin_theta * np.sin(phi), cos_theta)\n    )\n</code></pre>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.Translation","title":"Translation","text":"<p>               Bases: <code>BaseOperation</code></p> <p>Class for a translation operation.</p> <p>This operation moves atoms to a random position within the simulation cell. The center of mass of the selected atoms is preserved by applying the same displacement to all atoms in the selection.</p> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector that translates the selected atoms to a random position.</p> </li> </ul>"},{"location":"reference/quansino/operations/displacement.html#quansino.operations.displacement.TranslationRotation","title":"TranslationRotation","text":"<pre><code>TranslationRotation()\n</code></pre> <p>               Bases: <code>BaseOperation</code></p> <p>Class to perform both translation and rotation operations on atoms.</p> <p>This operation combines the Translation and Rotation operations, allowing atoms to be both translated and rotated in a single move.</p> <p>Attributes:</p> <ul> <li> <code>translation</code>               (<code>Translation</code>)           \u2013            <p>The translation operation.</p> </li> <li> <code>rotation</code>               (<code>Rotation</code>)           \u2013            <p>The rotation operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Displacement</code>           \u2013            <p>A displacement vector combining both translation and rotation effects.</p> </li> </ul> Source code in <code>quansino/operations/displacement.py</code> <pre><code>def __init__(self):\n    self.translation = Translation()\n    self.rotation = Rotation()\n</code></pre>"},{"location":"reference/quansino/utils/atoms.html","title":"atoms","text":"<p>Utility functions for working with atoms.</p>"},{"location":"reference/quansino/utils/atoms.html#quansino.utils.atoms.has_constraint","title":"has_constraint","text":"<pre><code>has_constraint(atoms, constraint_type)\n</code></pre> <p>Check if the Atoms object has the specified constraint.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to check.</p> </li> <li> <code>constraint_type</code>               (<code>type[FixConstraint] | str</code>)           \u2013            <p>The constraint type to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the Atoms object has constraints, False otherwise.</p> </li> </ul> Source code in <code>quansino/utils/atoms.py</code> <pre><code>def has_constraint(atoms: Atoms, constraint_type: type[FixConstraint] | str) -&gt; bool:\n    \"\"\"\n    Check if the Atoms object has the specified constraint.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The Atoms object to check.\n    constraint_type : type[FixConstraint] | str\n        The constraint type to check.\n\n    Returns\n    -------\n    bool\n        True if the Atoms object has constraints, False otherwise.\n    \"\"\"\n    if not isinstance(constraint_type, str):\n        constraint_type = constraint_type.__name__\n\n    return any(c for c in atoms.constraints if c.__class__.__name__ == constraint_type)\n</code></pre>"},{"location":"reference/quansino/utils/atoms.html#quansino.utils.atoms.reinsert_atoms","title":"reinsert_atoms","text":"<pre><code>reinsert_atoms(atoms, new_atoms, indices)\n</code></pre> <p>Reinsert atoms into an Atoms object, in place. This differs from pure insertion in that it assumes that <code>new_atoms</code> were previously removed from <code>atoms</code> at their old <code>indices</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to insert atoms into.</p> </li> <li> <code>new_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object with the atoms to insert.</p> </li> <li> <code>indices</code>               (<code>IntegerArray</code>)           \u2013            <p>The indices that <code>new_atoms</code> were previously removed from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>The Atoms object with the reinserted atoms.</p> </li> </ul> Source code in <code>quansino/utils/atoms.py</code> <pre><code>def reinsert_atoms(atoms: Atoms, new_atoms: Atoms, indices: IntegerArray) -&gt; None:\n    \"\"\"\n    Reinsert atoms into an Atoms object, in place. This differs from pure insertion in that it assumes that `new_atoms` were previously removed from `atoms` at their old `indices`.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The Atoms object to insert atoms into.\n    new_atoms : Atoms\n        The Atoms object with the atoms to insert.\n    indices : IntegerArray\n        The indices that `new_atoms` were previously removed from.\n\n    Returns\n    -------\n    None\n        The Atoms object with the reinserted atoms.\n    \"\"\"\n    len_atoms = len(atoms)\n    len_new_atoms = len(new_atoms)\n\n    for name in atoms.arrays:\n        array = (\n            new_atoms.get_masses()\n            if name == \"masses\"\n            else new_atoms.arrays.get(name, 0)\n        )\n\n        new_array = np.zeros(\n            (len_atoms + len_new_atoms, *array.shape[1:]),\n            dtype=atoms.arrays[name].dtype,\n        )\n        mask = np.ones(len(new_array), dtype=bool)\n        mask[indices] = False\n        new_array[mask] = atoms.arrays[name]\n        new_array[indices] = array\n        atoms.arrays[name] = new_array\n\n    for name, array in new_atoms.arrays.items():\n        if name not in atoms.arrays:\n            new_array = np.zeros((len(atoms), *array.shape[1:]), dtype=array.dtype)\n            new_array[indices] = array\n\n            atoms.set_array(name, new_array)\n</code></pre>"},{"location":"reference/quansino/utils/atoms.html#quansino.utils.atoms.search_molecules","title":"search_molecules","text":"<pre><code>search_molecules(atoms, cutoff, required_size=None, default_array=None)\n</code></pre> <p>Search for molecules in the Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to search.</p> </li> <li> <code>cutoff</code>               (<code>float | list[float] | tuple[float] | dict[tuple[str, str], float]</code>)           \u2013            <p>The cutoff distance to use for the search. Can be a single float, a list or tuple of floats with the same length as the number of atom types, or a dictionary with the atom types as keys and the cutoff distances as values.</p> </li> <li> <code>required_size</code>               (<code>int | tuple | None</code>, default:                   <code>None</code> )           \u2013            <p>The required size of molecules to include. If int, only molecules of that exact size are included. If tuple, molecules with sizes between the two values (inclusive) are included. If None, all molecules are included (equivalent to (0, len(atoms))).</p> </li> <li> <code>default_array</code>               (<code>IntegerArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Default array to use for molecule assignment. If None, creates an array filled with -1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IntegerArray</code>           \u2013            <p>An array of molecule indices for each atom, where atoms belonging to the same molecule have the same index. Atoms not belonging to any qualifying molecule have index -1.</p> </li> </ul> Source code in <code>quansino/utils/atoms.py</code> <pre><code>def search_molecules(\n    atoms: Atoms,\n    cutoff: float | list[float] | tuple[float] | dict[tuple[str, str], float],\n    required_size: int | tuple | None = None,\n    default_array: IntegerArray | None = None,\n) -&gt; AdjacencyMatrix:\n    \"\"\"\n    Search for molecules in the Atoms object.\n\n    Parameters\n    ----------\n    atoms : Atoms\n        The Atoms object to search.\n    cutoff : float | list[float] | tuple[float] | dict[tuple[str, str], float]\n        The cutoff distance to use for the search. Can be a single float, a list or tuple of floats\n        with the same length as the number of atom types, or a dictionary with the atom types as keys\n        and the cutoff distances as values.\n    required_size : int | tuple | None, optional\n        The required size of molecules to include. If int, only molecules of that exact size are included.\n        If tuple, molecules with sizes between the two values (inclusive) are included.\n        If None, all molecules are included (equivalent to (0, len(atoms))).\n    default_array : IntegerArray | None, optional\n        Default array to use for molecule assignment. If None, creates an array filled with -1.\n\n    Returns\n    -------\n    IntegerArray\n        An array of molecule indices for each atom, where atoms belonging to the same molecule\n        have the same index. Atoms not belonging to any qualifying molecule have index -1.\n    \"\"\"\n    indices, neighbors = neighbor_list(\n        \"ij\", atoms, cutoff=cutoff, self_interaction=False\n    )\n\n    connectivity = np.full((len(atoms), len(atoms)), 0)\n    connectivity[indices, neighbors] = 1\n\n    molecules = np.asarray(default_array) or np.full(len(atoms), -1)\n\n    if required_size is None:\n        required_size = (0, len(atoms))\n    elif isinstance(required_size, int):\n        required_size = (required_size, required_size)\n\n    for n, mol in enumerate(nx.connected_components(nx.from_numpy_array(connectivity))):\n        molecule_array = np.fromiter(mol, dtype=int)\n        if required_size[0] &lt;= molecule_array.size &lt;= required_size[1]:\n            molecules[molecule_array] = n\n\n    return molecules\n</code></pre>"},{"location":"reference/quansino/utils/dynamics.html","title":"dynamics","text":""},{"location":"reference/quansino/utils/dynamics.html#quansino.utils.dynamics.maxwell_boltzmann_distribution","title":"maxwell_boltzmann_distribution","text":"<pre><code>maxwell_boltzmann_distribution(context, forced=False)\n</code></pre> <p>Set the momenta of the atoms in the context according to the Maxwell-Boltzmann distribution at the specified temperature.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>DisplacementContext</code>)           \u2013            <p>The simulation context containing the atoms.</p> </li> <li> <code>forced</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the momenta will be scaled to exactly match the specified temperature, by default False.</p> </li> </ul> Source code in <code>quansino/utils/dynamics.py</code> <pre><code>def maxwell_boltzmann_distribution(\n    context: DisplacementContext, forced: bool = False\n) -&gt; None:\n    \"\"\"\n    Set the momenta of the atoms in the context according to the Maxwell-Boltzmann distribution at the specified temperature.\n\n    Parameters\n    ----------\n    context : DisplacementContext\n        The simulation context containing the atoms.\n    forced : bool, optional\n        If True, the momenta will be scaled to exactly match the specified temperature, by default False.\n    \"\"\"\n    temperature = context.temperature * kB\n    atoms = context.atoms\n\n    atoms.set_momenta(\n        context.rng.standard_normal((len(context.atoms), 3))\n        * np.sqrt(atoms.get_masses() * temperature)[:, None]\n    )\n\n    if forced:\n        real_temperature = (\n            2 * atoms.get_kinetic_energy() / atoms.get_number_of_degrees_of_freedom()\n        ) + 1.0e-15\n        scale = np.sqrt(temperature / real_temperature)\n    else:\n        scale = 1.0\n\n    atoms.set_momenta(atoms.get_momenta() * scale)\n</code></pre>"},{"location":"reference/quansino/utils/moves.html","title":"moves","text":"<p>Module for storing and managing moves with their acceptance criteria.</p>"},{"location":"reference/quansino/utils/moves.html#quansino.utils.moves.MoveStorage","title":"MoveStorage  <code>dataclass</code>","text":"<pre><code>MoveStorage(move, criteria, interval, probability, minimum_count)\n</code></pre> <p>               Bases: <code>Generic[MoveType, CriteriaType]</code></p> <p>Dataclass to store moves and their acceptance criteria.</p> <p>This generic dataclass pairs moves with their corresponding acceptance criteria and execution parameters for Monte Carlo simulations.</p> <p>Attributes:</p> <ul> <li> <code>move</code>               (<code>MoveType</code>)           \u2013            <p>The move object implementing the Move protocol.</p> </li> <li> <code>criteria</code>               (<code>CriteriaType</code>)           \u2013            <p>The acceptance criteria object implementing the Criteria protocol.</p> </li> <li> <code>interval</code>               (<code>int</code>)           \u2013            <p>The interval at which the move is selected.</p> </li> <li> <code>probability</code>               (<code>float</code>)           \u2013            <p>The probability of the move being selected.</p> </li> <li> <code>minimum_count</code>               (<code>int</code>)           \u2013            <p>The minimum number of times the move must be performed in a cycle.</p> </li> </ul>"},{"location":"reference/quansino/utils/moves.html#quansino.utils.moves.MoveStorage.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return a string representation of the <code>MoveStorage</code> object.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string representation of the <code>MoveStorage</code> object.</p> </li> </ul> Source code in <code>quansino/utils/moves.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the `MoveStorage` object.\n\n    Returns\n    -------\n    str\n        A string representation of the `MoveStorage` object.\n    \"\"\"\n    return f\"{self.__class__.__name__}(move={self.move}, criteria={self.criteria}, interval={self.interval}, probability={self.probability}, minimum_count={self.minimum_count})\"\n</code></pre>"},{"location":"reference/quansino/utils/moves.html#quansino.utils.moves.MoveStorage.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Load the MoveStorage object from a dictionary. This method is used to restore the state of the MoveStorage object from a saved state.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary representation of the MoveStorage object.</p> </li> </ul> Source code in <code>quansino/utils/moves.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"\n    Load the MoveStorage object from a dictionary.\n    This method is used to restore the state of the MoveStorage object from a saved state.\n\n    Parameters\n    ----------\n    data : dict[str, Any]\n        A dictionary representation of the MoveStorage object.\n    \"\"\"\n    data = deepcopy(data)\n\n    kwargs = data[\"kwargs\"]\n\n    move_data = kwargs[\"move\"]\n    move_class: type[MoveType] = get_typed_class(move_data[\"name\"], Move)\n    kwargs[\"move\"] = move_class.from_dict(move_data)\n\n    criteria_data = kwargs[\"criteria\"]\n    criteria_class: type[CriteriaType] = get_typed_class(\n        criteria_data[\"name\"], Criteria\n    )\n    kwargs[\"criteria\"] = criteria_class.from_dict(criteria_data)\n\n    return cls(**kwargs)\n</code></pre>"},{"location":"reference/quansino/utils/moves.html#quansino.utils.moves.MoveStorage.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary representation of the MoveStorage object.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary representation of the MoveStorage object.</p> </li> </ul> Source code in <code>quansino/utils/moves.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Return a dictionary representation of the MoveStorage object.\n\n    Returns\n    -------\n    dict[str, Any]\n        A dictionary representation of the MoveStorage object.\n    \"\"\"\n    return {\n        \"name\": self.__class__.__name__,\n        \"kwargs\": {\n            \"move\": self.move.to_dict(),\n            \"criteria\": self.criteria.to_dict(),\n            \"interval\": self.interval,\n            \"probability\": self.probability,\n            \"minimum_count\": self.minimum_count,\n        },\n    }\n</code></pre>"},{"location":"reference/quansino/utils/strings.html","title":"strings","text":""},{"location":"reference/quansino/utils/strings.html#quansino.utils.strings.get_auto_header_format","title":"get_auto_header_format","text":"<pre><code>get_auto_header_format(data_format)\n</code></pre> <p>Convert a data format string to a header format string.</p> <p>Parameters:</p> <ul> <li> <code>data_format</code>               (<code>str</code>)           \u2013            <p>The data format string to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The converted header format string to maintain alignment. Returns '&gt;10s' if the function fails to parse the data format.</p> </li> </ul> <p>Examples:</p> <p>get_header_format('10.3f') -&gt; '&gt;10s' get_header_format('4s') -&gt; '&gt;4s'</p> Source code in <code>quansino/utils/strings.py</code> <pre><code>def get_auto_header_format(data_format: str) -&gt; str:\n    \"\"\"\n    Convert a data format string to a header format string.\n\n    Parameters\n    ----------\n    data_format\n        The data format string to convert.\n\n    Returns\n    -------\n    str\n        The converted header format string to maintain alignment.\n        Returns '&gt;10s' if the function fails to parse the data format.\n\n    Examples\n    --------\n    get_header_format('10.3f') -&gt; '&gt;10s'\n    get_header_format('4s') -&gt; '&gt;4s'\n    \"\"\"\n    return re.sub(\n        r\":([&lt;&gt;^])?(\\d+)?[^}]*\",\n        lambda m: f':{m.group(1) or \"&gt;\"}{m.group(2) or \"10\"}s',\n        data_format,\n    )\n</code></pre>"}]}